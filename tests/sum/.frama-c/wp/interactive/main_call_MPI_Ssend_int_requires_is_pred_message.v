(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require bool.Bool.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.
Require real.Real.
Require real.RealInfix.
Require real.FromInt.
Require map.Map.
Require option.Option.

Parameter eqb:
  forall {a:Type} {a_WT:WhyType a}, a -> a -> Init.Datatypes.bool.

Axiom eqb1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a), ((eqb x y) = Init.Datatypes.true) <-> (x = y).

Axiom eqb_false :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a), ((eqb x y) = Init.Datatypes.false) <-> ~ (x = y).

Parameter neqb:
  forall {a:Type} {a_WT:WhyType a}, a -> a -> Init.Datatypes.bool.

Axiom neqb1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a), ((neqb x y) = Init.Datatypes.true) <-> ~ (x = y).

Parameter zlt: Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Parameter zleq:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom zlt1 :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((zlt x y) = Init.Datatypes.true) <-> (x < y)%Z.

Axiom zleq1 :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((zleq x y) = Init.Datatypes.true) <-> (x <= y)%Z.

Parameter rlt:
  Reals.Rdefinitions.R -> Reals.Rdefinitions.R -> Init.Datatypes.bool.

Parameter rleq:
  Reals.Rdefinitions.R -> Reals.Rdefinitions.R -> Init.Datatypes.bool.

Axiom rlt1 :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R),
  ((rlt x y) = Init.Datatypes.true) <-> (x < y)%R.

Axiom rleq1 :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R),
  ((rleq x y) = Init.Datatypes.true) <-> (x <= y)%R.

(* Why3 assumption *)
Definition real_of_int (x:Numbers.BinNums.Z) : Reals.Rdefinitions.R :=
  BuiltIn.IZR x.

Axiom c_euclidian :
  forall (n:Numbers.BinNums.Z) (d:Numbers.BinNums.Z), ~ (d = 0%Z) ->
  (n = (((ZArith.BinInt.Z.quot n d) * d)%Z + (ZArith.BinInt.Z.rem n d))%Z).

Axiom cmod_remainder :
  forall (n:Numbers.BinNums.Z) (d:Numbers.BinNums.Z),
  ((0%Z <= n)%Z -> (0%Z < d)%Z ->
   (0%Z <= (ZArith.BinInt.Z.rem n d))%Z /\ ((ZArith.BinInt.Z.rem n d) < d)%Z) /\
  ((n <= 0%Z)%Z -> (0%Z < d)%Z ->
   ((-d)%Z < (ZArith.BinInt.Z.rem n d))%Z /\
   ((ZArith.BinInt.Z.rem n d) <= 0%Z)%Z) /\
  ((0%Z <= n)%Z -> (d < 0%Z)%Z ->
   (0%Z <= (ZArith.BinInt.Z.rem n d))%Z /\
   ((ZArith.BinInt.Z.rem n d) < (-d)%Z)%Z) /\
  ((n <= 0%Z)%Z -> (d < 0%Z)%Z ->
   (d < (ZArith.BinInt.Z.rem n d))%Z /\ ((ZArith.BinInt.Z.rem n d) <= 0%Z)%Z).

Axiom cdiv_neutral :
  forall (a:Numbers.BinNums.Z), ((ZArith.BinInt.Z.quot a 1%Z) = a).

Axiom cdiv_inv :
  forall (a:Numbers.BinNums.Z), ~ (a = 0%Z) ->
  ((ZArith.BinInt.Z.quot a a) = 1%Z).

Axiom cdiv_closed_remainder :
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z) (n:Numbers.BinNums.Z),
  (0%Z <= a)%Z -> (0%Z <= b)%Z ->
  (0%Z <= (b - a)%Z)%Z /\ ((b - a)%Z < n)%Z ->
  ((ZArith.BinInt.Z.rem a n) = (ZArith.BinInt.Z.rem b n)) -> (a = b).

(* Why3 assumption *)
Inductive addr :=
  | addr'mk : Numbers.BinNums.Z -> Numbers.BinNums.Z -> addr.
Axiom addr_WhyType : WhyType addr.
Existing Instance addr_WhyType.

(* Why3 assumption *)
Definition offset (v:addr) : Numbers.BinNums.Z :=
  match v with
  | addr'mk x x1 => x1
  end.

(* Why3 assumption *)
Definition base (v:addr) : Numbers.BinNums.Z :=
  match v with
  | addr'mk x x1 => x
  end.

Parameter addr_le: addr -> addr -> Prop.

Parameter addr_lt: addr -> addr -> Prop.

Parameter addr_le_bool: addr -> addr -> Init.Datatypes.bool.

Parameter addr_lt_bool: addr -> addr -> Init.Datatypes.bool.

Axiom addr_le_def :
  forall (p:addr) (q:addr), ((base p) = (base q)) ->
  addr_le p q <-> ((offset p) <= (offset q))%Z.

Axiom addr_lt_def :
  forall (p:addr) (q:addr), ((base p) = (base q)) ->
  addr_lt p q <-> ((offset p) < (offset q))%Z.

Axiom addr_le_bool_def :
  forall (p:addr) (q:addr),
  addr_le p q <-> ((addr_le_bool p q) = Init.Datatypes.true).

Axiom addr_lt_bool_def :
  forall (p:addr) (q:addr),
  addr_lt p q <-> ((addr_lt_bool p q) = Init.Datatypes.true).

(* Why3 assumption *)
Definition null : addr := addr'mk 0%Z 0%Z.

(* Why3 assumption *)
Definition global (b:Numbers.BinNums.Z) : addr := addr'mk b 0%Z.

(* Why3 assumption *)
Definition shift (p:addr) (k:Numbers.BinNums.Z) : addr :=
  addr'mk (base p) ((offset p) + k)%Z.

(* Why3 assumption *)
Definition included (p:addr) (a:Numbers.BinNums.Z) (q:addr)
    (b:Numbers.BinNums.Z) : Prop :=
  (0%Z < a)%Z ->
  (0%Z <= b)%Z /\
  ((base p) = (base q)) /\
  ((offset q) <= (offset p))%Z /\
  (((offset p) + a)%Z <= ((offset q) + b)%Z)%Z.

(* Why3 assumption *)
Definition separated (p:addr) (a:Numbers.BinNums.Z) (q:addr)
    (b:Numbers.BinNums.Z) : Prop :=
  (a <= 0%Z)%Z \/
  (b <= 0%Z)%Z \/
  ~ ((base p) = (base q)) \/
  (((offset q) + b)%Z <= (offset p))%Z \/
  (((offset p) + a)%Z <= (offset q))%Z.

(* Why3 assumption *)
Definition eqmem {a:Type} {a_WT:WhyType a} (m1:addr -> a) (m2:addr -> a)
    (p:addr) (a1:Numbers.BinNums.Z) : Prop :=
  forall (q:addr), included q 1%Z p a1 -> ((m1 q) = (m2 q)).

Parameter havoc:
  forall {a:Type} {a_WT:WhyType a}, (addr -> a) -> (addr -> a) -> addr ->
  Numbers.BinNums.Z -> addr -> a.

(* Why3 assumption *)
Definition valid_rw (m:Numbers.BinNums.Z -> Numbers.BinNums.Z) (p:addr)
    (n:Numbers.BinNums.Z) : Prop :=
  (0%Z < n)%Z ->
  (0%Z < (base p))%Z /\
  (0%Z <= (offset p))%Z /\ (((offset p) + n)%Z <= (m (base p)))%Z.

(* Why3 assumption *)
Definition valid_rd (m:Numbers.BinNums.Z -> Numbers.BinNums.Z) (p:addr)
    (n:Numbers.BinNums.Z) : Prop :=
  (0%Z < n)%Z ->
  ~ (0%Z = (base p)) /\
  (0%Z <= (offset p))%Z /\ (((offset p) + n)%Z <= (m (base p)))%Z.

(* Why3 assumption *)
Definition valid_obj (m:Numbers.BinNums.Z -> Numbers.BinNums.Z) (p:addr)
    (n:Numbers.BinNums.Z) : Prop :=
  (0%Z < n)%Z ->
  (p = null) \/
  ~ (0%Z = (base p)) /\
  (0%Z <= (offset p))%Z /\ (((offset p) + n)%Z <= (1%Z + (m (base p)))%Z)%Z.

(* Why3 assumption *)
Definition invalid (m:Numbers.BinNums.Z -> Numbers.BinNums.Z) (p:addr)
    (n:Numbers.BinNums.Z) : Prop :=
  (n <= 0%Z)%Z \/
  ((base p) = 0%Z) \/
  ((m (base p)) <= (offset p))%Z \/ (((offset p) + n)%Z <= 0%Z)%Z.

Axiom valid_rw_rd :
  forall (m:Numbers.BinNums.Z -> Numbers.BinNums.Z), forall (p:addr),
  forall (n:Numbers.BinNums.Z), valid_rw m p n -> valid_rd m p n.

Axiom valid_string :
  forall (m:Numbers.BinNums.Z -> Numbers.BinNums.Z), forall (p:addr),
  ((base p) < 0%Z)%Z ->
  (0%Z <= (offset p))%Z /\ ((offset p) < (m (base p)))%Z ->
  valid_rd m p 1%Z /\ ~ valid_rw m p 1%Z.

Axiom separated_1 :
  forall (p:addr) (q:addr),
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z) (i:Numbers.BinNums.Z)
    (j:Numbers.BinNums.Z),
  separated p a q b -> ((offset p) <= i)%Z /\ (i < ((offset p) + a)%Z)%Z ->
  ((offset q) <= j)%Z /\ (j < ((offset q) + b)%Z)%Z ->
  ~ ((addr'mk (base p) i) = (addr'mk (base q) j)).

Parameter region: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter linked: (Numbers.BinNums.Z -> Numbers.BinNums.Z) -> Prop.

Parameter sconst: (addr -> Numbers.BinNums.Z) -> Prop.

(* Why3 assumption *)
Definition framed (m:addr -> addr) : Prop :=
  forall (p:addr), ((region (base p)) <= 0%Z)%Z ->
  ((region (base (m p))) <= 0%Z)%Z.

Axiom separated_included :
  forall (p:addr) (q:addr),
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z), (0%Z < a)%Z ->
  (0%Z < b)%Z -> separated p a q b -> ~ included p a q b.

Axiom included_trans :
  forall (p:addr) (q:addr) (r:addr),
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z) (c:Numbers.BinNums.Z),
  included p a q b -> included q b r c -> included p a r c.

Axiom separated_trans :
  forall (p:addr) (q:addr) (r:addr),
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z) (c:Numbers.BinNums.Z),
  included p a q b -> separated q b r c -> separated p a r c.

Axiom separated_sym :
  forall (p:addr) (q:addr),
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z),
  separated p a q b <-> separated q b p a.

Axiom eqmem_included :
  forall {a:Type} {a_WT:WhyType a},
  forall (m1:addr -> a) (m2:addr -> a), forall (p:addr) (q:addr),
  forall (a1:Numbers.BinNums.Z) (b:Numbers.BinNums.Z), included p a1 q b ->
  eqmem m1 m2 q b -> eqmem m1 m2 p a1.

Axiom eqmem_sym :
  forall {a:Type} {a_WT:WhyType a},
  forall (m1:addr -> a) (m2:addr -> a), forall (p:addr),
  forall (a1:Numbers.BinNums.Z), eqmem m1 m2 p a1 -> eqmem m2 m1 p a1.

Axiom havoc_access :
  forall {a:Type} {a_WT:WhyType a},
  forall (m0:addr -> a) (m1:addr -> a), forall (q:addr) (p:addr),
  forall (a1:Numbers.BinNums.Z),
  (separated q 1%Z p a1 -> ((havoc m0 m1 p a1 q) = (m1 q))) /\
  (~ separated q 1%Z p a1 -> ((havoc m0 m1 p a1 q) = (m0 q))).

Parameter cinits: (addr -> Init.Datatypes.bool) -> Prop.

(* Why3 assumption *)
Definition is_init_range (m:addr -> Init.Datatypes.bool) (p:addr)
    (l:Numbers.BinNums.Z) : Prop :=
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < l)%Z ->
  ((m (shift p i)) = Init.Datatypes.true).

Parameter set_init:
  (addr -> Init.Datatypes.bool) -> addr -> Numbers.BinNums.Z ->
  addr -> Init.Datatypes.bool.

Axiom set_init_access :
  forall (m:addr -> Init.Datatypes.bool), forall (q:addr) (p:addr),
  forall (a:Numbers.BinNums.Z),
  (separated q 1%Z p a -> ((set_init m p a q) = (m q))) /\
  (~ separated q 1%Z p a -> ((set_init m p a q) = Init.Datatypes.true)).

(* Why3 assumption *)
Definition monotonic_init (m1:addr -> Init.Datatypes.bool)
    (m2:addr -> Init.Datatypes.bool) : Prop :=
  forall (p:addr), ((m1 p) = Init.Datatypes.true) ->
  ((m2 p) = Init.Datatypes.true).

Parameter int_of_addr: addr -> Numbers.BinNums.Z.

Parameter addr_of_int: Numbers.BinNums.Z -> addr.

Axiom table : Type.
Parameter table_WhyType : WhyType table.
Existing Instance table_WhyType.

Parameter table_of_base: Numbers.BinNums.Z -> table.

Parameter table_to_offset: table -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom table_to_offset_zero :
  forall (t:table), ((table_to_offset t 0%Z) = 0%Z).

Axiom table_to_offset_monotonic :
  forall (t:table), forall (o1:Numbers.BinNums.Z) (o2:Numbers.BinNums.Z),
  (o1 <= o2)%Z <-> ((table_to_offset t o1) <= (table_to_offset t o2))%Z.

Axiom int_of_addr_bijection :
  forall (a:Numbers.BinNums.Z), ((int_of_addr (addr_of_int a)) = a).

Axiom addr_of_int_bijection :
  forall (p:addr), ((addr_of_int (int_of_addr p)) = p).

Axiom addr_of_null : ((int_of_addr null) = 0%Z).

Axiom S15_c_protocol : Type.
Parameter S15_c_protocol_WhyType : WhyType S15_c_protocol.
Existing Instance S15_c_protocol_WhyType.

Axiom list : forall (a:Type), Type.
Parameter list_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (list a).
Existing Instance list_WhyType.

Parameter nil: forall {a:Type} {a_WT:WhyType a}, list a.

Parameter cons: forall {a:Type} {a_WT:WhyType a}, a -> list a -> list a.

Parameter concat:
  forall {a:Type} {a_WT:WhyType a}, list a -> list a -> list a.

Parameter repeat:
  forall {a:Type} {a_WT:WhyType a}, list a -> Numbers.BinNums.Z -> list a.

Parameter length:
  forall {a:Type} {a_WT:WhyType a}, list a -> Numbers.BinNums.Z.

Parameter nth:
  forall {a:Type} {a_WT:WhyType a}, list a -> Numbers.BinNums.Z -> a.

Axiom length_pos :
  forall {a:Type} {a_WT:WhyType a}, forall (w:list a), (0%Z <= (length w))%Z.

Axiom length_nil :
  forall {a:Type} {a_WT:WhyType a}, ((length (nil : list a)) = 0%Z).

Axiom length_nil_bis :
  forall {a:Type} {a_WT:WhyType a},
  forall (w:list a), ((length w) = 0%Z) -> (w = (nil : list a)).

Axiom length_cons :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (w:list a), ((length (cons x w)) = (1%Z + (length w))%Z).

Axiom length_concat :
  forall {a:Type} {a_WT:WhyType a},
  forall (u:list a) (v:list a),
  ((length (concat u v)) = ((length u) + (length v))%Z).

Axiom length_repeat :
  forall {a:Type} {a_WT:WhyType a},
  forall (w:list a) (n:Numbers.BinNums.Z), (0%Z <= n)%Z ->
  ((length (repeat w n)) = (n * (length w))%Z).

Axiom nth_cons :
  forall {a:Type} {a_WT:WhyType a},
  forall (k:Numbers.BinNums.Z) (x:a) (w:list a),
  ((k = 0%Z) -> ((nth (cons x w) k) = x)) /\
  (~ (k = 0%Z) -> ((nth (cons x w) k) = (nth w (k - 1%Z)%Z))).

Axiom nth_concat :
  forall {a:Type} {a_WT:WhyType a},
  forall (u:list a) (v:list a) (k:Numbers.BinNums.Z),
  ((k < (length u))%Z -> ((nth (concat u v) k) = (nth u k))) /\
  (~ (k < (length u))%Z ->
   ((nth (concat u v) k) = (nth v (k - (length u))%Z))).

Axiom nth_repeat :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Numbers.BinNums.Z) (k:Numbers.BinNums.Z) (w:list a),
  (0%Z <= k)%Z /\ (k < (n * (length w))%Z)%Z -> (0%Z < (length w))%Z ->
  ((nth (repeat w n) k) = (nth w (ZArith.BinInt.Z.rem k (length w)))).

(* Why3 assumption *)
Definition vlist_eq {a:Type} {a_WT:WhyType a} (u:list a) (v:list a) : Prop :=
  ((length u) = (length v)) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length u))%Z ->
   ((nth u i) = (nth v i))).

Axiom extensionality :
  forall {a:Type} {a_WT:WhyType a},
  forall (u:list a) (v:list a), vlist_eq u v -> (u = v).

Axiom eq_nil_concat :
  forall {a:Type} {a_WT:WhyType a},
  forall (w:list a),
  vlist_eq (concat (nil : list a) w) w /\
  vlist_eq (concat w (nil : list a)) w.

Axiom rw_nil_concat_left :
  forall {a:Type} {a_WT:WhyType a},
  forall (w:list a), ((concat (nil : list a) w) = w).

Axiom rw_nil_concat_right :
  forall {a:Type} {a_WT:WhyType a},
  forall (w:list a), ((concat w (nil : list a)) = w).

Axiom eq_cons_concat :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (v:list a) (w:list a),
  vlist_eq (concat (cons x v) w) (cons x (concat v w)).

Axiom rw_cons_concat :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (v:list a) (w:list a),
  ((concat (cons x v) w) = (cons x (concat v w))).

Axiom rw_nil_cons_concat :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (w:list a), ((concat (cons x (nil : list a)) w) = (cons x w)).

Axiom eq_assoc_concat :
  forall {a:Type} {a_WT:WhyType a},
  forall (u:list a) (v:list a) (w:list a),
  vlist_eq (concat (concat u v) w) (concat u (concat v w)).

Axiom rw_nil_repeat :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Numbers.BinNums.Z), (0%Z <= n)%Z ->
  ((repeat (nil : list a) n) = (nil : list a)).

Axiom rw_repeat_zero :
  forall {a:Type} {a_WT:WhyType a},
  forall (w:list a), ((repeat w 0%Z) = (nil : list a)).

Axiom eq_repeat_one :
  forall {a:Type} {a_WT:WhyType a},
  forall (w:list a), vlist_eq (repeat w 1%Z) w.

Axiom rw_repeat_one :
  forall {a:Type} {a_WT:WhyType a}, forall (w:list a), ((repeat w 1%Z) = w).

Axiom eq_repeat_concat :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:Numbers.BinNums.Z) (q:Numbers.BinNums.Z) (w:list a),
  (0%Z <= p)%Z -> (0%Z <= q)%Z ->
  vlist_eq (repeat w (p + q)%Z) (concat (repeat w p) (repeat w q)).

Axiom rw_repeat_concat :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:Numbers.BinNums.Z) (q:Numbers.BinNums.Z) (w:list a),
  (0%Z <= p)%Z -> (0%Z <= q)%Z ->
  ((repeat w (p + q)%Z) = (concat (repeat w p) (repeat w q))).

Axiom rw_repeat_after :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:Numbers.BinNums.Z) (w:list a), (0%Z <= p)%Z ->
  ((concat (repeat w p) w) = (repeat w (p + 1%Z)%Z)).

Axiom rw_repeat_before :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:Numbers.BinNums.Z) (w:list a), (0%Z <= p)%Z ->
  ((concat w (repeat w p)) = (repeat w (p + 1%Z)%Z)).

Parameter repeat_box:
  forall {a:Type} {a_WT:WhyType a}, list a -> Numbers.BinNums.Z -> list a.

Axiom rw_repeat_box_unfold :
  forall {a:Type} {a_WT:WhyType a},
  forall (w:list a) (n:Numbers.BinNums.Z), ((repeat_box w n) = (repeat w n)).

Axiom rw_repeat_plus_box_unfold :
  forall {a:Type} {a_WT:WhyType a},
  forall (w:list a) (a1:Numbers.BinNums.Z) (b:Numbers.BinNums.Z),
  (0%Z <= a1)%Z -> (0%Z <= b)%Z ->
  ((repeat_box w (a1 + b)%Z) = (concat (repeat w a1) (repeat w b))).

Axiom rw_repeat_plus_one_box_unfold :
  forall {a:Type} {a_WT:WhyType a},
  forall (w:list a) (n:Numbers.BinNums.Z), (0%Z < n)%Z ->
  ((repeat_box w n) = (concat (repeat w (n - 1%Z)%Z) w)) /\
  ((repeat_box w (n + 1%Z)%Z) = (concat (repeat w n) w)).

(* Why3 assumption *)
Inductive mpi_datatype :=
  | MPI_char : mpi_datatype
  | MPI_int : mpi_datatype
  | MPI_float : mpi_datatype.
Axiom mpi_datatype_WhyType : WhyType mpi_datatype.
Existing Instance mpi_datatype_WhyType.

(* Why3 assumption *)
Inductive mpi_op :=
  | MPI_max : mpi_op
  | MPI_min : mpi_op
  | MPI_sum : mpi_op
  | MPI_prod : mpi_op
  | MPI_land : mpi_op
  | MPI_band : mpi_op
  | MPI_lor : mpi_op
  | MPI_bor : mpi_op
  | MPI_lxor : mpi_op
  | MPI_bxor : mpi_op
  | MPI_maxloc : mpi_op
  | MPI_minloc : mpi_op
  | MPI_replace : mpi_op
  | MPI_no_op : mpi_op.
Axiom mpi_op_WhyType : WhyType mpi_op.
Existing Instance mpi_op_WhyType.

Parameter size: Numbers.BinNums.Z.

(* Why3 assumption *)
Inductive protocol :=
  | IntMessage : Numbers.BinNums.Z -> Numbers.BinNums.Z ->
      Numbers.BinNums.Z -> Numbers.BinNums.Z ->
      (list Numbers.BinNums.Z -> Init.Datatypes.bool) -> protocol
  | IntBroadcast : Numbers.BinNums.Z -> Numbers.BinNums.Z ->
      (list Numbers.BinNums.Z -> Init.Datatypes.bool) ->
      (list Numbers.BinNums.Z -> protocol) -> protocol
  | IntGhostBroadcast : Numbers.BinNums.Z -> Numbers.BinNums.Z ->
      (list Numbers.BinNums.Z -> Init.Datatypes.bool) ->
      (list Numbers.BinNums.Z -> protocol) -> protocol
  | Gather : Numbers.BinNums.Z -> Numbers.BinNums.Z -> mpi_datatype ->
      protocol
  | Scatter : Numbers.BinNums.Z -> Numbers.BinNums.Z -> mpi_datatype ->
      protocol
  | Reduce : Numbers.BinNums.Z -> Numbers.BinNums.Z -> mpi_datatype ->
      mpi_op -> protocol
  | Allgather : Numbers.BinNums.Z -> mpi_datatype -> protocol
  | Allreduce : Numbers.BinNums.Z -> mpi_datatype -> mpi_op -> protocol
  | Foreach : Numbers.BinNums.Z -> Numbers.BinNums.Z ->
      (Numbers.BinNums.Z -> protocol) -> protocol
  | If : Init.Datatypes.bool -> protocol -> protocol -> protocol
  | Seq : protocol -> protocol -> protocol
  | Skip : protocol.
Axiom protocol_WhyType : WhyType protocol.
Existing Instance protocol_WhyType.

Axiom array : forall (a:Type), Type.
Parameter array_WhyType :
  forall (a:Type) {a_WT:WhyType a}, WhyType (array a).
Existing Instance array_WhyType.

Parameter elts:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a.

Parameter length1:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z.

Axiom array'invariant :
  forall {a:Type} {a_WT:WhyType a},
  forall (self:array a), (0%Z <= (length1 self))%Z.

(* Why3 assumption *)
Definition mixfix_lbrb {a:Type} {a_WT:WhyType a} (a1:array a)
    (i:Numbers.BinNums.Z) : a :=
  elts a1 i.

Parameter mixfix_lblsmnrb:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a ->
  array a.

Axiom mixfix_lblsmnrb'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  ((length1 (mixfix_lblsmnrb a1 i v)) = (length1 a1)) /\
  ((elts (mixfix_lblsmnrb a1 i v)) = (map.Map.set (elts a1) i v)).

Parameter make:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z -> a -> array a.

Axiom make_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Numbers.BinNums.Z) (v:a), (0%Z <= n)%Z ->
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < n)%Z ->
   ((mixfix_lbrb (make n v) i) = v)) /\
  ((length1 (make n v)) = n).

Parameter rank: Numbers.BinNums.Z.

Parameter isIntMessage: protocol -> Prop.

Axiom IsIntMessage :
  forall (src:Numbers.BinNums.Z) (dst:Numbers.BinNums.Z)
    (data_size:Numbers.BinNums.Z) (t:Numbers.BinNums.Z)
    (pre:list Numbers.BinNums.Z -> Init.Datatypes.bool),
  isIntMessage (IntMessage src dst data_size t pre).

Parameter isIntBroadcast: protocol -> Prop.

Axiom IsIntBroadcast :
  forall (r:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (pred:list Numbers.BinNums.Z -> Init.Datatypes.bool)
    (cont:list Numbers.BinNums.Z -> protocol),
  isIntBroadcast (IntBroadcast r data_size pred cont).

Parameter isGather: protocol -> Prop.

Axiom IsGather :
  forall (r:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (mt:mpi_datatype),
  isGather (Gather r data_size mt).

Parameter isScatter: protocol -> Prop.

Axiom IsScatter :
  forall (r:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (mt:mpi_datatype),
  isScatter (Scatter r data_size mt).

Parameter isReduce: protocol -> Prop.

Axiom IsReduce :
  forall (r:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (mt:mpi_datatype) (op:mpi_op),
  isReduce (Reduce r data_size mt op).

Parameter isAllgather: protocol -> Prop.

Axiom IsAllgather :
  forall (data_size:Numbers.BinNums.Z) (mt:mpi_datatype),
  isAllgather (Allgather data_size mt).

Parameter isAllreduce: protocol -> Prop.

Axiom IsAllreduce :
  forall (data_size:Numbers.BinNums.Z) (mt:mpi_datatype) (op:mpi_op),
  isAllreduce (Allreduce data_size mt op).

Parameter isForeach: protocol -> Prop.

Axiom IsForeach :
  forall (low:Numbers.BinNums.Z) (high:Numbers.BinNums.Z)
    (body:Numbers.BinNums.Z -> protocol),
  isForeach (Foreach low high body).

Parameter isSkip: protocol -> Prop.

Axiom IsSkip : isSkip Skip.

Parameter isMessageforIntSend:
  protocol -> Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z ->
  list Numbers.BinNums.Z -> Prop.

Axiom isforIntSend :
  forall (dest:Numbers.BinNums.Z) (count:Numbers.BinNums.Z)
    (tag:Numbers.BinNums.Z) (src:Numbers.BinNums.Z) (dst:Numbers.BinNums.Z)
    (data_size:Numbers.BinNums.Z) (t:Numbers.BinNums.Z)
    (data:list Numbers.BinNums.Z)
    (pre:list Numbers.BinNums.Z -> Init.Datatypes.bool),
  (0%Z <= src)%Z /\
  (src < size)%Z /\
  (0%Z <= dst)%Z /\
  (dst < size)%Z /\
  ~ (dst = src) /\
  (src = rank) /\ (dest = dst) /\ (data_size = count) /\ (tag = t) ->
  isMessageforIntSend (IntMessage src dst data_size t pre) dest count tag
  data.

Parameter isPredIntMessage: protocol -> list Numbers.BinNums.Z -> Prop.

Axiom isPredIntMessage1 :
  forall (src:Numbers.BinNums.Z) (dst:Numbers.BinNums.Z)
    (data_size:Numbers.BinNums.Z) (t:Numbers.BinNums.Z)
    (data:list Numbers.BinNums.Z)
    (pre:list Numbers.BinNums.Z -> Init.Datatypes.bool),
  ((pre data) = Init.Datatypes.true) ->
  isPredIntMessage (IntMessage src dst data_size t pre) data.

Parameter isMessageforIntRecv:
  protocol -> Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z ->
  Prop.

Axiom isforIntRecv :
  forall (source:Numbers.BinNums.Z) (count:Numbers.BinNums.Z)
    (tag:Numbers.BinNums.Z) (src:Numbers.BinNums.Z) (dst:Numbers.BinNums.Z)
    (data_size:Numbers.BinNums.Z) (t:Numbers.BinNums.Z)
    (pre:list Numbers.BinNums.Z -> Init.Datatypes.bool),
  (0%Z <= src)%Z /\
  (src < size)%Z /\
  (0%Z <= dst)%Z /\
  (dst < size)%Z /\
  ~ (dst = src) /\
  (src = source) /\ (dst = rank) /\ (data_size = count) /\ (tag = t) ->
  isMessageforIntRecv (IntMessage src dst data_size t pre) source count tag.

Parameter predIntMessage: protocol -> list Numbers.BinNums.Z -> Prop.

Axiom PredIntMessage :
  forall (src:Numbers.BinNums.Z) (dst:Numbers.BinNums.Z)
    (data_size:Numbers.BinNums.Z) (t:Numbers.BinNums.Z)
    (data:list Numbers.BinNums.Z)
    (pre:list Numbers.BinNums.Z -> Init.Datatypes.bool),
  predIntMessage (IntMessage src dst data_size t pre) data ->
  ((pre data) = Init.Datatypes.true).

Parameter isforIntBroadcast:
  protocol -> Numbers.BinNums.Z -> Numbers.BinNums.Z ->
  list Numbers.BinNums.Z -> Prop.

Axiom isIntBroadcast1 :
  forall (root:Numbers.BinNums.Z) (r:Numbers.BinNums.Z)
    (count:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (data:list Numbers.BinNums.Z)
    (pred:list Numbers.BinNums.Z -> Init.Datatypes.bool)
    (cont:list Numbers.BinNums.Z -> protocol),
  (0%Z <= r)%Z /\
  (r < size)%Z /\
  (root = r) /\
  (data_size = count) /\
  ((rank = root) -> ((pred data) = Init.Datatypes.true)) ->
  isforIntBroadcast (IntBroadcast r data_size pred cont) root count data.

Parameter isforIntGhostBroadcast:
  protocol -> Numbers.BinNums.Z -> Numbers.BinNums.Z ->
  list Numbers.BinNums.Z -> Prop.

Axiom isIntGhostBroadcast :
  forall (root:Numbers.BinNums.Z) (r:Numbers.BinNums.Z)
    (count:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (data:list Numbers.BinNums.Z)
    (pred:list Numbers.BinNums.Z -> Init.Datatypes.bool)
    (cont:list Numbers.BinNums.Z -> protocol),
  (0%Z <= r)%Z /\
  (r < size)%Z /\
  (root = r) /\
  (data_size = count) /\
  ((rank = root) -> ((pred data) = Init.Datatypes.true)) ->
  isforIntGhostBroadcast (IntGhostBroadcast r data_size pred cont) root count
  data.

Parameter predIntBroadcast: protocol -> list Numbers.BinNums.Z -> Prop.

Axiom PredIntBroadcast :
  forall (r:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (pred:list Numbers.BinNums.Z -> Init.Datatypes.bool)
    (cont:list Numbers.BinNums.Z -> protocol) (data:list Numbers.BinNums.Z),
  predIntBroadcast (IntBroadcast r data_size pred cont) data ->
  ((pred data) = Init.Datatypes.true).

Axiom PredIntGhostBroadcast :
  forall (r:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (pred:list Numbers.BinNums.Z -> Init.Datatypes.bool)
    (cont:list Numbers.BinNums.Z -> protocol) (data:list Numbers.BinNums.Z),
  predIntBroadcast (IntGhostBroadcast r data_size pred cont) data ->
  ((pred data) = Init.Datatypes.true).

Parameter countiIntBroadcast:
  protocol -> protocol -> protocol -> list Numbers.BinNums.Z -> Prop.

Axiom CountiIntBroadcast :
  forall (r:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (pred:list Numbers.BinNums.Z -> Init.Datatypes.bool)
    (cont:list Numbers.BinNums.Z -> protocol) (data:list Numbers.BinNums.Z)
    (old_n:protocol) (new_p:protocol),
  countiIntBroadcast (IntBroadcast r data_size pred cont) old_n new_p data ->
  (new_p = (Seq (cont data) old_n)).

Axiom CountiIntGhostBroadcast :
  forall (r:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (pred:list Numbers.BinNums.Z -> Init.Datatypes.bool)
    (cont:list Numbers.BinNums.Z -> protocol) (data:list Numbers.BinNums.Z)
    (old_n:protocol) (new_p:protocol),
  countiIntBroadcast (IntGhostBroadcast r data_size pred cont) old_n new_p
  data -> (new_p = (Seq (cont data) old_n)).

Parameter isforGather:
  protocol -> Numbers.BinNums.Z -> Numbers.BinNums.Z -> mpi_datatype -> Prop.

Axiom isGather1 :
  forall (root:Numbers.BinNums.Z) (r:Numbers.BinNums.Z)
    (count:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (datatype:mpi_datatype) (mt:mpi_datatype),
  (0%Z <= r)%Z /\
  (r < size)%Z /\ (root = r) /\ (data_size = count) /\ (datatype = mt) ->
  isforGather (Gather r data_size mt) root count datatype.

Parameter isforScatter:
  protocol -> Numbers.BinNums.Z -> Numbers.BinNums.Z -> mpi_datatype -> Prop.

Axiom isScatter1 :
  forall (root:Numbers.BinNums.Z) (r:Numbers.BinNums.Z)
    (count:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (datatype:mpi_datatype) (mt:mpi_datatype),
  (0%Z <= r)%Z /\
  (r < size)%Z /\ (root = r) /\ (data_size = count) /\ (datatype = mt) ->
  isforScatter (Scatter r data_size mt) root count datatype.

Parameter isforReduce:
  protocol -> Numbers.BinNums.Z -> Numbers.BinNums.Z -> mpi_datatype ->
  mpi_op -> Prop.

Axiom isReduce1 :
  forall (root:Numbers.BinNums.Z) (r:Numbers.BinNums.Z)
    (count:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (datatype:mpi_datatype) (mt:mpi_datatype) (op:mpi_op) (opera:mpi_op),
  (0%Z <= r)%Z /\
  (r < size)%Z /\
  (root = r) /\ (data_size = count) /\ (datatype = mt) /\ (opera = op) ->
  isforReduce (Reduce r data_size mt op) root count datatype opera.

Parameter isforAllgather:
  protocol -> Numbers.BinNums.Z -> mpi_datatype -> Prop.

Axiom isAllgather1 :
  forall (data_size:Numbers.BinNums.Z) (count:Numbers.BinNums.Z)
    (datatype:mpi_datatype) (mt:mpi_datatype),
  (data_size = count) /\ (datatype = mt) ->
  isforAllgather (Allgather data_size mt) count datatype.

Parameter isforAllreduce:
  protocol -> Numbers.BinNums.Z -> mpi_datatype -> mpi_op -> Prop.

Axiom isAllreduce1 :
  forall (data_size:Numbers.BinNums.Z) (count:Numbers.BinNums.Z)
    (datatype:mpi_datatype) (mt:mpi_datatype) (op:mpi_op) (opera:mpi_op),
  (data_size = count) /\ (datatype = mt) /\ (opera = op) ->
  isforAllreduce (Allreduce data_size mt op) count datatype opera.

Parameter simpl: protocol -> protocol.

Axiom simpl_seq_1 : forall (p:protocol), ((simpl (Seq Skip p)) = p).

Axiom simpl_seq_2 : forall (p:protocol), ((simpl (Seq p Skip)) = p).

Axiom simp_if_true :
  forall (b:Init.Datatypes.bool) (p1:protocol) (p2:protocol),
  (b = Init.Datatypes.true) -> ((simpl (If b p1 p2)) = p1).

Axiom simp_if_false :
  forall (b:Init.Datatypes.bool) (p1:protocol) (p2:protocol),
  ~ (b = Init.Datatypes.true) -> ((simpl (If b p1 p2)) = p2).

Axiom simpl_intmessage :
  forall (source:Numbers.BinNums.Z) (dest:Numbers.BinNums.Z)
    (data_size:Numbers.BinNums.Z) (tag:Numbers.BinNums.Z)
    (pre:list Numbers.BinNums.Z -> Init.Datatypes.bool),
  (0%Z <= source)%Z /\
  (source < size)%Z /\
  (0%Z <= dest)%Z /\
  (dest < size)%Z /\
  ~ (dest = source) /\ ~ (rank = source) /\ ~ (rank = dest) ->
  ((simpl (IntMessage source dest data_size tag pre)) = Skip).

Axiom simpl_foreach_1 :
  forall (low:Numbers.BinNums.Z) (high:Numbers.BinNums.Z)
    (body:Numbers.BinNums.Z -> protocol),
  (low <= high)%Z ->
  ((simpl (Foreach low high body)) =
   (Seq (body low) (Foreach (low + 1%Z)%Z high body))).

Axiom simpl_foreach_2 :
  forall (low:Numbers.BinNums.Z) (high:Numbers.BinNums.Z)
    (body:Numbers.BinNums.Z -> protocol),
  (high < low)%Z -> ((simpl (Foreach low high body)) = Skip).

Axiom simpl_Skip : ((simpl Skip) = Skip).

Parameter fsimpl: protocol -> protocol.

Axiom fsimpl_foreach :
  forall (low:Numbers.BinNums.Z) (high:Numbers.BinNums.Z)
    (body:Numbers.BinNums.Z -> protocol),
  (forall (i:Numbers.BinNums.Z), (low <= i)%Z /\ (i <= high)%Z ->
   ((simpl (body i)) = Skip)) ->
  ((fsimpl (Foreach low high body)) = Skip).

Parameter split: protocol -> Numbers.BinNums.Z -> protocol.

Axiom split_foreach :
  forall (low:Numbers.BinNums.Z) (high:Numbers.BinNums.Z)
    (c:Numbers.BinNums.Z) (body:Numbers.BinNums.Z -> protocol),
  (low <= c)%Z /\ (c <= high)%Z ->
  ((split (Foreach low high body) c) =
   (Seq (Foreach low (c - 1%Z)%Z body) (Foreach c high body))).

Parameter split_right: protocol -> Numbers.BinNums.Z -> protocol.

Axiom split_right_foreach :
  forall (low:Numbers.BinNums.Z) (high:Numbers.BinNums.Z)
    (c:Numbers.BinNums.Z) (body:Numbers.BinNums.Z -> protocol),
  (low <= high)%Z ->
  ((split_right (Foreach low high body) c) = (Foreach c high body)).

Parameter assoc: protocol -> protocol.

Axiom Assoc :
  forall (h:protocol) (q:protocol) (p:protocol),
  ((assoc (Seq (Seq h q) p)) = (Seq h (Seq q p))).

(* Why3 assumption *)
Fixpoint getFirst (p:protocol) {struct p}: protocol :=
  match p with
  | Seq h _ => getFirst h
  | p1 => p1
  end.

(* Why3 assumption *)
Fixpoint aux (p:protocol) {struct p}: Init.Datatypes.option protocol :=
  match p with
  | Seq h q =>
      match aux h with
      | Init.Datatypes.None => Init.Datatypes.Some q
      | Init.Datatypes.Some p1 => Init.Datatypes.Some (Seq p1 q)
      end
  | _ => Init.Datatypes.None
  end.

(* Why3 assumption *)
Definition getNext (p:protocol) : protocol :=
  match aux p with
  | Init.Datatypes.None => Skip
  | Init.Datatypes.Some p1 => p1
  end.

Parameter P_set_type: S15_c_protocol -> protocol -> Prop.

Parameter L_get_type: S15_c_protocol -> protocol.

Axiom Q_link :
  forall (p:protocol) (s:S15_c_protocol), P_set_type s p ->
  ((L_get_type s) = p).

Parameter sum:
  (Numbers.BinNums.Z -> Numbers.BinNums.Z) -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom sum'def :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z),
  ((b <= a)%Z -> ((sum f a b) = 0%Z)) /\
  (~ (b <= a)%Z ->
   ((sum f a b) = ((sum f a (b - 1%Z)%Z) + (f (b - 1%Z)%Z))%Z)).

Axiom sum_left :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z),
  (a < b)%Z -> ((sum f a b) = ((f a) + (sum f (a + 1%Z)%Z b))%Z).

Axiom sum_ext :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z)
    (g:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z),
  (forall (i:Numbers.BinNums.Z), (a <= i)%Z /\ (i < b)%Z -> ((f i) = (g i))) ->
  ((sum f a b) = (sum g a b)).

Axiom sum_le :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z)
    (g:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z),
  (forall (i:Numbers.BinNums.Z), (a <= i)%Z /\ (i < b)%Z ->
   ((f i) <= (g i))%Z) ->
  ((sum f a b) <= (sum g a b))%Z.

Axiom sum_zero :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z),
  (forall (i:Numbers.BinNums.Z), (a <= i)%Z /\ (i < b)%Z -> ((f i) = 0%Z)) ->
  ((sum f a b) = 0%Z).

Axiom sum_nonneg :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z),
  (forall (i:Numbers.BinNums.Z), (a <= i)%Z /\ (i < b)%Z -> (0%Z <= (f i))%Z) ->
  (0%Z <= (sum f a b))%Z.

Axiom sum_decomp :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z) (c:Numbers.BinNums.Z),
  (a <= b)%Z /\ (b <= c)%Z -> ((sum f a c) = ((sum f a b) + (sum f b c))%Z).

Axiom shift_left :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z)
    (g:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z) (c:Numbers.BinNums.Z) (d:Numbers.BinNums.Z),
  ((b - a)%Z = (d - c)%Z) ->
  (forall (i:Numbers.BinNums.Z), (a <= i)%Z /\ (i < b)%Z ->
   ((f i) = (g ((c + i)%Z - a)%Z))) ->
  ((sum f a b) = (sum g c d)).

Parameter offset1: Numbers.BinNums.Z.

Axiom offset'def :
  ((size <= 1000%Z)%Z -> (offset1 = (ZArith.BinInt.Z.quot 1000%Z size))) /\
  (~ (size <= 1000%Z)%Z -> (offset1 = 1%Z)).

Parameter active: Numbers.BinNums.Z.

Axiom active'def :
  ((size <= 1000%Z)%Z -> (active = size)) /\
  (~ (size <= 1000%Z)%Z -> (active = 1000%Z)).

(* Why3 assumption *)
Definition p1 (l1:list Numbers.BinNums.Z) (i:Numbers.BinNums.Z)
    (l2:list Numbers.BinNums.Z) : Prop :=
  forall (k:Numbers.BinNums.Z), (0%Z <= k)%Z /\ (k < offset1)%Z ->
  ((nth l1 ((i * offset1)%Z + k)%Z) = (nth l2 k)).

(* Why3 assumption *)
Definition p2 (l1:list Numbers.BinNums.Z) (i:Numbers.BinNums.Z)
    (l2:list Numbers.BinNums.Z) : Prop :=
  ((sum
    ((fun (y0:list Numbers.BinNums.Z) (y1:Numbers.BinNums.Z) => nth y0 y1)
     l1)
    (i * offset1)%Z ((i + 1%Z)%Z * offset1)%Z)
   = (nth l2 0%Z)).

Parameter p1_closure:
  list Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> list Numbers.BinNums.Z -> Init.Datatypes.bool.

Parameter p2_closure:
  list Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> list Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom p1_closure_def :
  forall (y:list Numbers.BinNums.Z) (y1:Numbers.BinNums.Z)
    (y2:list Numbers.BinNums.Z),
  ((p1_closure y y1 y2) = Init.Datatypes.true) <-> p1 y y1 y2.

Axiom p2_closure_def :
  forall (y:list Numbers.BinNums.Z) (y1:Numbers.BinNums.Z)
    (y2:list Numbers.BinNums.Z),
  ((p2_closure y y1 y2) = Init.Datatypes.true) <-> p2 y y1 y2.

(* Why3 assumption *)
Definition f (l1:list Numbers.BinNums.Z) : protocol :=
  Seq
  (Foreach 1%Z (active - 1%Z)%Z
   (fun (i:Numbers.BinNums.Z) =>
    IntMessage 0%Z i offset1 1%Z (p1_closure l1 i)))
  (Foreach 1%Z (active - 1%Z)%Z
   (fun (i:Numbers.BinNums.Z) => IntMessage i 0%Z 1%Z 1%Z (p2_closure l1 i))).

(* Why3 assumption *)
Definition the_protocol : protocol :=
  IntGhostBroadcast 0%Z 1000%Z
  (fun (us:list Numbers.BinNums.Z) => Init.Datatypes.true)
  (fun (y0:list Numbers.BinNums.Z) => f y0).

Parameter L_to_list:
  (addr -> Numbers.BinNums.Z) -> addr -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> list Numbers.BinNums.Z.

Axiom Q_to_list_empty :
  forall (Mint:addr -> Numbers.BinNums.Z) (a:addr) (i:Numbers.BinNums.Z)
    (n:Numbers.BinNums.Z),
  (n <= i)%Z -> ((L_to_list Mint a i n) = (nil : list Numbers.BinNums.Z)).

(* Why3 assumption *)
Definition shift_S19___fc_FILE (p:addr) (k:Numbers.BinNums.Z) : addr :=
  shift p (2%Z * k)%Z.

(* Why3 assumption *)
Definition IsInit_S19___fc_FILE (p:addr) (Init:addr -> Init.Datatypes.bool) :
    Prop :=
  ((Init (shift p 1%Z)) = Init.Datatypes.true) /\
  ((Init (shift p 0%Z)) = Init.Datatypes.true).

(* Why3 assumption *)
Definition IsInitArray_S19___fc_FILE (p:addr) (n:Numbers.BinNums.Z)
    (Init:addr -> Init.Datatypes.bool) : Prop :=
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z -> (i < n)%Z ->
  IsInit_S19___fc_FILE (shift_S19___fc_FILE p i) Init.

(* Why3 assumption *)
Definition IsInitArray_sint8 (p:addr) (n:Numbers.BinNums.Z)
    (Init:addr -> Init.Datatypes.bool) : Prop :=
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z -> (i < n)%Z ->
  ((Init (shift p i)) = Init.Datatypes.true).

Axiom Q_IsInit_S19___fc_FILE_range :
  forall (p:addr) (Init:addr -> Init.Datatypes.bool),
  is_init_range Init p 2%Z <-> IsInit_S19___fc_FILE p Init.

Axiom Q_IsInitArray_S19___fc_FILE_range :
  forall (p:addr) (n:Numbers.BinNums.Z) (Init:addr -> Init.Datatypes.bool),
  is_init_range Init p (2%Z * n)%Z <-> IsInitArray_S19___fc_FILE p n Init.

Axiom Q_IsInitArray_sint8_range :
  forall (p:addr) (n:Numbers.BinNums.Z) (Init:addr -> Init.Datatypes.bool),
  is_init_range Init p n <-> IsInitArray_sint8 p n Init.

Axiom Q_to_list_cons :
  forall (Mint:addr -> Numbers.BinNums.Z) (a:addr) (i:Numbers.BinNums.Z)
    (n:Numbers.BinNums.Z),
  let x := ((-1%Z)%Z + n)%Z in
  (i < n)%Z ->
  ((L_to_list Mint a i n) =
   (concat (L_to_list Mint a i x)
    (cons (Mint (shift a x)) (nil : list Numbers.BinNums.Z)))).

Axiom Q_to_list_length :
  forall (Mint:addr -> Numbers.BinNums.Z) (a:addr) (i:Numbers.BinNums.Z)
    (n:Numbers.BinNums.Z),
  (i <= n)%Z -> ((i + (length (L_to_list Mint a i n)))%Z = n).

Axiom Q_to_list_concat :
  forall (Mint:addr -> Numbers.BinNums.Z) (a:addr) (i:Numbers.BinNums.Z)
    (k:Numbers.BinNums.Z) (n:Numbers.BinNums.Z),
  (i <= k)%Z -> (k <= n)%Z ->
  ((L_to_list Mint a i n) =
   (concat (L_to_list Mint a i k) (L_to_list Mint a k n))).

Axiom Q_to_list_nth :
  forall (Mint:addr -> Numbers.BinNums.Z) (a:addr) (i:Numbers.BinNums.Z)
    (n:Numbers.BinNums.Z) (k:Numbers.BinNums.Z),
  let x := (i + k)%Z in
  (i < n)%Z -> (0%Z <= k)%Z -> (x < n)%Z ->
  ((Mint (shift a x)) = (nth (L_to_list Mint a i n) k)).

Axiom Q_to_list_nth_shift :
  forall (Mint:addr -> Numbers.BinNums.Z) (a:addr) (i:Numbers.BinNums.Z)
    (n:Numbers.BinNums.Z) (k:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (i < n)%Z -> (0%Z <= k)%Z -> ((i + k)%Z < n)%Z ->
  ((Mint (shift a ((i + j)%Z + k)%Z)) =
   (nth (L_to_list Mint (shift a j) i n) k)).

Axiom Q_G_mpi_mpi_op_max_33_region : ((region 34%Z) = 0%Z).

Axiom S6_mpi_op_t : Type.
Parameter S6_mpi_op_t_WhyType : WhyType S6_mpi_op_t.
Existing Instance S6_mpi_op_t_WhyType.

Parameter Length_of_S6_mpi_op_t: Numbers.BinNums.Z.

Axiom Q_Positive_Length_of_S6_mpi_op_t : (0%Z < Length_of_S6_mpi_op_t)%Z.

Axiom Q_G_mpi_mpi_op_max_33_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 34%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_min_32_region : ((region 33%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_min_32_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 33%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_sum_34_region : ((region 35%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_sum_34_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 35%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_prod_35_region : ((region 36%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_prod_35_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 36%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_land_36_region : ((region 37%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_land_36_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 37%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_band_37_region : ((region 38%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_band_37_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 38%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_lor_38_region : ((region 39%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_lor_38_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 39%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_bor_39_region : ((region 40%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_bor_39_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 40%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_lxor_40_region : ((region 41%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_lxor_40_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 41%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_bxor_41_region : ((region 42%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_bxor_41_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 42%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_maxloc_42_region : ((region 43%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_maxloc_42_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 43%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_minloc_43_region : ((region 44%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_minloc_43_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 44%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_replace_44_region : ((region 45%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_replace_44_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 45%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_no_op_45_region : ((region 46%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_no_op_45_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 46%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_int_51_region : ((region 52%Z) = 0%Z).

Axiom S2_mpi_datatype_t : Type.
Parameter S2_mpi_datatype_t_WhyType : WhyType S2_mpi_datatype_t.
Existing Instance S2_mpi_datatype_t_WhyType.

Parameter Length_of_S2_mpi_datatype_t: Numbers.BinNums.Z.

Axiom Q_Positive_Length_of_S2_mpi_datatype_t :
  (0%Z < Length_of_S2_mpi_datatype_t)%Z.

Axiom Q_G_mpi_mpi_int_51_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 52%Z) = Length_of_S2_mpi_datatype_t).

Axiom Q_G_mpi_mpi_char_46_region : ((region 47%Z) = 0%Z).

Axiom Q_G_mpi_mpi_char_46_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 47%Z) = Length_of_S2_mpi_datatype_t).

Axiom Q_G_mpi_mpi_float_57_region : ((region 58%Z) = 0%Z).

Axiom Q_G_mpi_mpi_float_57_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 58%Z) = Length_of_S2_mpi_datatype_t).

Axiom Q_L_g_2060_region : ((region 2061%Z) = 2%Z).

Axiom Q_L_g_2060_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 2061%Z) = 0%Z).

Axiom Q_L_data_2056_region : ((region 2057%Z) = 2%Z).

Axiom Q_L_data_2056_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 2057%Z) = 0%Z).

Axiom Q_L_tmp_2069_region : ((region 2070%Z) = 2%Z).

Axiom Q_L_tmp_2069_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 2070%Z) = 0%Z).

Axiom Q_L_g_2073_region : ((region 2074%Z) = 2%Z).

Axiom Q_L_g_2073_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 2074%Z) = 0%Z).

Axiom Q_L_sum_2071_region : ((region 2072%Z) = 2%Z).

Axiom Q_L_sum_2071_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 2072%Z) = 0%Z).

Axiom Q_L_g_2078_region : ((region 2079%Z) = 2%Z).

Axiom Q_L_g_2078_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 2079%Z) = 0%Z).

Axiom Q_G___fc_fopen_732_region : ((region 733%Z) = 0%Z).

Axiom Q_G___fc_fopen_732_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 733%Z) = 32%Z).

Axiom Q_G___fc_fopen_732_init :
  forall (t:addr -> Init.Datatypes.bool), cinits t ->
  is_init_range t (shift (global 733%Z) 0%Z) 32%Z.

Axiom Q_G___fc_tmpnam_740_region : ((region 741%Z) = 0%Z).

Axiom Q_G___fc_tmpnam_740_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 741%Z) = 2048%Z).

Axiom Q_G___fc_tmpnam_740_init :
  forall (t:addr -> Init.Datatypes.bool), cinits t ->
  is_init_range t (shift (global 741%Z) 0%Z) 2048%Z.

Axiom Q_G___fc_random48_counter_1602_region : ((region 1603%Z) = 0%Z).

Axiom Q_G___fc_random48_counter_1602_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 1603%Z) = 3%Z).

Axiom Q_G___fc_random48_counter_1602_init :
  forall (t:addr -> Init.Datatypes.bool), cinits t ->
  is_init_range t (shift (global 1603%Z) 0%Z) 3%Z.

(* Why3 assumption *)
Definition size_constrain (s:Numbers.BinNums.Z) : Prop :=
  (2%Z <= s)%Z /\ ((s <= 1000%Z)%Z -> ((ZArith.BinInt.Z.rem 1000%Z s) = 0%Z)).

(* Why3 assumption *)
Definition is_bool (x:Numbers.BinNums.Z) : Prop := (x = 0%Z) \/ (x = 1%Z).

(* Why3 assumption *)
Definition is_uint8 (x:Numbers.BinNums.Z) : Prop :=
  (0%Z <= x)%Z /\ (x < 256%Z)%Z.

(* Why3 assumption *)
Definition is_sint8 (x:Numbers.BinNums.Z) : Prop :=
  ((-128%Z)%Z <= x)%Z /\ (x < 128%Z)%Z.

(* Why3 assumption *)
Definition is_uint16 (x:Numbers.BinNums.Z) : Prop :=
  (0%Z <= x)%Z /\ (x < 65536%Z)%Z.

(* Why3 assumption *)
Definition is_sint16 (x:Numbers.BinNums.Z) : Prop :=
  ((-32768%Z)%Z <= x)%Z /\ (x < 32768%Z)%Z.

(* Why3 assumption *)
Definition is_uint32 (x:Numbers.BinNums.Z) : Prop :=
  (0%Z <= x)%Z /\ (x < 4294967296%Z)%Z.

(* Why3 assumption *)
Definition is_sint32 (x:Numbers.BinNums.Z) : Prop :=
  ((-2147483648%Z)%Z <= x)%Z /\ (x < 2147483648%Z)%Z.

(* Why3 assumption *)
Definition is_uint64 (x:Numbers.BinNums.Z) : Prop :=
  (0%Z <= x)%Z /\ (x < 18446744073709551616%Z)%Z.

(* Why3 assumption *)
Definition is_sint64 (x:Numbers.BinNums.Z) : Prop :=
  ((-9223372036854775808%Z)%Z <= x)%Z /\ (x < 9223372036854775808%Z)%Z.

Axiom is_bool0 : is_bool 0%Z.

Axiom is_bool1 : is_bool 1%Z.

Parameter to_bool: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom to_bool'def :
  forall (x:Numbers.BinNums.Z),
  ((x = 0%Z) -> ((to_bool x) = 0%Z)) /\ (~ (x = 0%Z) -> ((to_bool x) = 1%Z)).

Parameter to_uint8: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_sint8: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_uint16: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_sint16: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_uint32: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_sint32: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_uint64: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_sint64: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter two_power_abs: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom two_power_abs_is_positive :
  forall (n:Numbers.BinNums.Z), (0%Z < (two_power_abs n))%Z.

Axiom two_power_abs_plus_pos :
  forall (n:Numbers.BinNums.Z) (m:Numbers.BinNums.Z), (0%Z <= n)%Z ->
  (0%Z <= m)%Z ->
  ((two_power_abs (n + m)%Z) = ((two_power_abs n) * (two_power_abs m))%Z).

Axiom two_power_abs_plus_one :
  forall (n:Numbers.BinNums.Z), (0%Z <= n)%Z ->
  ((two_power_abs (n + 1%Z)%Z) = (2%Z * (two_power_abs n))%Z).

(* Why3 assumption *)
Definition is_uint (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) : Prop :=
  (0%Z <= x)%Z /\ (x < (two_power_abs n))%Z.

(* Why3 assumption *)
Definition is_sint (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) : Prop :=
  ((-(two_power_abs n))%Z <= x)%Z /\ (x < (two_power_abs n))%Z.

Parameter to_uint:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_sint:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom is_to_uint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z), is_uint n (to_uint n x).

Axiom is_to_sint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z), is_sint n (to_sint n x).

Axiom is_to_uint8 : forall (x:Numbers.BinNums.Z), is_uint8 (to_uint8 x).

Axiom is_to_sint8 : forall (x:Numbers.BinNums.Z), is_sint8 (to_sint8 x).

Axiom is_to_uint16 : forall (x:Numbers.BinNums.Z), is_uint16 (to_uint16 x).

Axiom is_to_sint16 : forall (x:Numbers.BinNums.Z), is_sint16 (to_sint16 x).

Axiom is_to_uint32 : forall (x:Numbers.BinNums.Z), is_uint32 (to_uint32 x).

Axiom is_to_sint32 : forall (x:Numbers.BinNums.Z), is_sint32 (to_sint32 x).

Axiom is_to_uint64 : forall (x:Numbers.BinNums.Z), is_uint64 (to_uint64 x).

Axiom is_to_sint64 : forall (x:Numbers.BinNums.Z), is_sint64 (to_sint64 x).

Axiom id_uint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  is_uint n x <-> ((to_uint n x) = x).

Axiom id_sint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  is_sint n x <-> ((to_sint n x) = x).

Axiom id_uint8 :
  forall (x:Numbers.BinNums.Z), is_uint8 x -> ((to_uint8 x) = x).

Axiom id_sint8 :
  forall (x:Numbers.BinNums.Z), is_sint8 x -> ((to_sint8 x) = x).

Axiom id_uint16 :
  forall (x:Numbers.BinNums.Z), is_uint16 x -> ((to_uint16 x) = x).

Axiom id_sint16 :
  forall (x:Numbers.BinNums.Z), is_sint16 x -> ((to_sint16 x) = x).

Axiom id_uint32 :
  forall (x:Numbers.BinNums.Z), is_uint32 x -> ((to_uint32 x) = x).

Axiom id_sint32 :
  forall (x:Numbers.BinNums.Z), is_sint32 x -> ((to_sint32 x) = x).

Axiom id_uint64 :
  forall (x:Numbers.BinNums.Z), is_uint64 x -> ((to_uint64 x) = x).

Axiom id_sint64 :
  forall (x:Numbers.BinNums.Z), is_sint64 x -> ((to_sint64 x) = x).

Axiom proj_uint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  ((to_uint n (to_uint n x)) = (to_uint n x)).

Axiom proj_sint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  ((to_sint n (to_sint n x)) = (to_sint n x)).

Axiom proj_uint8 :
  forall (x:Numbers.BinNums.Z), ((to_uint8 (to_uint8 x)) = (to_uint8 x)).

Axiom proj_sint8 :
  forall (x:Numbers.BinNums.Z), ((to_sint8 (to_sint8 x)) = (to_sint8 x)).

Axiom proj_uint16 :
  forall (x:Numbers.BinNums.Z), ((to_uint16 (to_uint16 x)) = (to_uint16 x)).

Axiom proj_sint16 :
  forall (x:Numbers.BinNums.Z), ((to_sint16 (to_sint16 x)) = (to_sint16 x)).

Axiom proj_uint32 :
  forall (x:Numbers.BinNums.Z), ((to_uint32 (to_uint32 x)) = (to_uint32 x)).

Axiom proj_sint32 :
  forall (x:Numbers.BinNums.Z), ((to_sint32 (to_sint32 x)) = (to_sint32 x)).

Axiom proj_uint64 :
  forall (x:Numbers.BinNums.Z), ((to_uint64 (to_uint64 x)) = (to_uint64 x)).

Axiom proj_sint64 :
  forall (x:Numbers.BinNums.Z), ((to_sint64 (to_sint64 x)) = (to_sint64 x)).

Axiom proj_su :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  ((to_sint n (to_uint n x)) = (to_uint n x)).

Axiom incl_su :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z), is_uint n x ->
  is_sint n x.

Axiom proj_su_uint :
  forall (n:Numbers.BinNums.Z) (m:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((to_sint (m + n)%Z (to_uint n x)) = (to_uint n x)).

Axiom proj_su_sint :
  forall (n:Numbers.BinNums.Z) (m:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((to_sint n (to_uint (m + (n + 1%Z)%Z)%Z x)) = (to_sint n x)).

Axiom proj_int8 :
  forall (x:Numbers.BinNums.Z), ((to_sint8 (to_uint8 x)) = (to_sint8 x)).

Axiom proj_int16 :
  forall (x:Numbers.BinNums.Z), ((to_sint16 (to_uint16 x)) = (to_sint16 x)).

Axiom proj_int32 :
  forall (x:Numbers.BinNums.Z), ((to_sint32 (to_uint32 x)) = (to_sint32 x)).

Axiom proj_int64 :
  forall (x:Numbers.BinNums.Z), ((to_sint64 (to_uint64 x)) = (to_sint64 x)).

Axiom proj_us_uint :
  forall (n:Numbers.BinNums.Z) (m:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((to_uint (n + 1%Z)%Z (to_sint (m + n)%Z x)) = (to_uint (n + 1%Z)%Z x)).

Axiom incl_uint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= i)%Z -> is_uint n x -> is_uint (n + i)%Z x.

Axiom incl_sint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= i)%Z -> is_sint n x -> is_sint (n + i)%Z x.

Axiom incl_int :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= i)%Z -> is_uint n x -> is_sint (n + i)%Z x.

(* Why3 goal *)
Theorem wp_goal :
  let a := global 2057%Z in
  let a1 := global 2061%Z in
  let a2 := shift a1 0%Z in
  forall (t:addr -> Numbers.BinNums.Z) (t1:addr -> Numbers.BinNums.Z)
    (t2:addr -> Numbers.BinNums.Z) (t3:addr -> Numbers.BinNums.Z)
    (i:Numbers.BinNums.Z) (i1:Numbers.BinNums.Z) (i2:Numbers.BinNums.Z)
    (i3:Numbers.BinNums.Z) (c:S15_c_protocol) (c1:S15_c_protocol)
    (c2:S15_c_protocol) (c3:S15_c_protocol) (c4:S15_c_protocol)
    (c5:S15_c_protocol),
  let a3 := L_get_type c3 in
  let a4 := getNext a3 in
  let a5 := L_get_type c in
  let a6 := getFirst a5 in
  let a7 := getFirst a3 in
  let a8 := havoc t3 t (shift a 0%Z) 1000%Z in
  let a9 := havoc t1 a8 a2 1000%Z in
  let a10 := L_to_list a9 a2 0%Z 1000%Z in
  let a11 := L_get_type c4 in
  let a12 := L_get_type c5 in
  let a13 := getFirst a12 in
  let a14 := havoc t2 a8 a2 1000%Z in
  (rank = 0%Z) -> (a4 = (getNext a5)) -> ((split_right a6 1%Z) = a6) ->
  ((split_right a6 i2) = a7) -> ((f a10) = a5) -> (0%Z < i2)%Z ->
  (0%Z < i)%Z -> (0%Z < size)%Z -> (i2 < i)%Z -> (0%Z <= i1)%Z ->
  (i2 <= i)%Z -> (1000%Z <= i1)%Z -> (i1 <= 1000%Z)%Z ->
  size_constrain size -> is_sint32 i3 -> is_sint32 i2 -> is_sint32 i1 ->
  is_sint32 i -> is_sint32 size -> P_set_type c5 the_protocol ->
  P_set_type c1 (assoc (L_get_type c2)) -> P_set_type c (simpl a11) ->
  P_set_type c2 (Seq (simpl a7) a4) -> predIntBroadcast a13 a10 ->
  isforIntGhostBroadcast a13 0%Z 1000%Z (L_to_list a14 a2 0%Z 1000%Z) ->
  countiIntBroadcast a13 (getNext a12) a11 a10 ->
  (size <= 1000%Z)%Z /\ (size = i) /\ ((ZArith.BinInt.Z.quot 1000%Z i) = i3) \/
  ~ (size <= 1000%Z)%Z /\ (i3 = 1%Z) /\ (i = 1000%Z) ->
  (forall (i4:Numbers.BinNums.Z), (0%Z < i4)%Z -> (i4 < i)%Z ->
   ((i3 * (1%Z + i4)%Z)%Z <= 1000%Z)%Z) ->
  (forall (i4:Numbers.BinNums.Z) (i5:Numbers.BinNums.Z), (0%Z < i5)%Z ->
   (i5 < i)%Z -> (0%Z <= i4)%Z -> (i4 < i3)%Z ->
   ((i4 + (i3 * i5)%Z)%Z <= 999%Z)%Z) ->
  (forall (i4:Numbers.BinNums.Z), (0%Z <= i4)%Z -> (i4 < i1)%Z ->
   ((a14 (shift a1 i4)) = (a8 (shift a i4)))) ->
  (forall (i4:Numbers.BinNums.Z),
   let a15 := shift a1 i4 in
   (0%Z <= i4)%Z -> (i4 <= 999%Z)%Z -> ((a14 a15) = (a9 a15))) ->
  isPredIntMessage (getFirst (L_get_type c1))
  (L_to_list a9 (shift a (i2 * i3)%Z) 0%Z i3).
(* Why3 intros a a1 a2 t t1 t2 t3 i i1 i2 i3 c c1 c2 c3 c4 c5 a3 a4 a5 a6 a7
        a8 a9 a10 a11 a12 a13 a14 h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13
        h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 h30
        h31. *)
Proof.
intros.
erewrite Q_link by apply H19.
erewrite Q_link by apply H21.
rewrite <- H2.
unfold a6.
rewrite <- H3.
unfold f.
simpl.
assert (H30: (i1 = 1000)%Z) by Lia.lia.
subst.
destruct active'def.
rewrite split_right_foreach by Lia.lia.
rewrite simpl_foreach_1 by Lia.lia.
rewrite Assoc.
simpl.
apply isPredIntMessage1.
apply p1_closure_def.
unfold p1.
intros.
unfold a10.
specialize(Q_to_list_nth a9 a2 0 1000 (i2*offset1 + k)).
simpl.
intros.
specialize(Q_to_list_nth_shift a9 a 0 i3 k (i2 * i3)).
simpl.
intros.
rewrite <- H33.
rewrite <- H34.
rewrite <- H29.
unfold a9.
destruct (havoc_access t1 a8 (shift a ((i2 * i3) + k)) a2 1000)
  as (H35 & _).
rewrite H35.
destruct H25.
* decompose [and] H25;clear H25.
  subst.
  destruct offset'def as (H37 & _).
  rewrite H37 by assumption.
  apply H28.

  apply Z.add_nonneg_nonneg;[ | Lia.lia].
  apply Ztac.mul_le; [ Lia.lia | Lia.lia].
  
  rewrite Z.add_comm.
  rewrite Z.mul_comm.
  apply Z.lt_le_pred.
  apply H27; [ Lia.lia | Lia.lia | Lia.lia | Lia.lia].
  
* decompose [and] H25;clear H25.
  subst.
  destruct offset'def as (_ & H37 ).
  rewrite H37 by assumption.
  apply H28.

  apply Z.add_nonneg_nonneg;[ | Lia.lia].
  apply Ztac.mul_le; [ Lia.lia | Lia.lia].
  
  rewrite Z.add_comm.
  rewrite Z.mul_comm.
  apply Z.lt_le_pred.
  apply H27; [ Lia.lia | Lia.lia | Lia.lia | Lia.lia].

* unfold separated.
  right.
  right.
  left.
  simpl.
  Lia.lia.

*  apply Z.add_nonneg_nonneg;[ | Lia.lia].
   apply Ztac.mul_le; [ Lia.lia | Lia.lia].

* rewrite Z.add_comm.
  rewrite Z.mul_comm.
  destruct H25.
  - decompose [and] H25;clear H25.
    subst.
    destruct offset'def as (H37 &_ ).
    rewrite H37 by assumption.
    apply H27;[ Lia.lia | Lia.lia | Lia.lia | Lia.lia].
  - decompose [and] H25;clear H25.
    subst.
    destruct offset'def as (_ &H37).
    rewrite H37 by assumption.
    apply H27;[ Lia.lia | Lia.lia | Lia.lia | Lia.lia].
* destruct H25.
  - decompose [and] H25;clear H25.
    subst.
    apply Z.quot_str_pos.
    Lia.lia.
  - decompose [and] H25;clear H25.
    subst.
    Lia.lia.

* Lia.lia.
* destruct H25.
  - decompose [and] H25;clear H25.
    subst.
    destruct offset'def as (H37 &_ ).
    Lia.lia.
  - decompose [and] H25;clear H25.
    subst.
    destruct offset'def as (_ & H37 ).
    Lia.lia.
* Lia.lia.
* destruct H25.
  - decompose [and] H25;clear H25.
    subst.
    destruct offset'def as (H37 &_ ).
    apply Z.add_nonneg_nonneg;[ | Lia.lia].
    apply Ztac.mul_le; [ Lia.lia | Lia.lia].
  - decompose [and] H25;clear H25.
    subst.
    destruct offset'def as (_ & H37 ).
    Lia.lia.
* destruct H25.
  - decompose [and] H25;clear H25.
    subst.
    destruct offset'def as (H37 &_ ).
    rewrite Z.add_comm.
    apply Z.lt_le_pred.
    rewrite H37 by assumption.
    rewrite Z.mul_comm.
    apply H27; [ Lia.lia | Lia.lia| Lia.lia | Lia.lia].
  - decompose [and] H25;clear H25.
    subst.
    destruct offset'def as (_ & H37 ).
    Lia.lia.
Qed.

