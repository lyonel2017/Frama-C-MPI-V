module MPI_Function

use protocol.MPI_Protocol
use protocol.MPI_Protocol_Handler
use int.Int

type mpi_protocol = {mutable p:protocol}

val s : mpi_protocol

val init (p:protocol) :unit
    writes {s.p}
    ensures{s.p=p}
    ensures{0 <= rank < size}

val ssend (dest:int) (count: int) (tag: int) (datatype: mpi_datatype) : unit
    writes { s.p }
    requires { 0 <= dest /\ dest < size }
    requires { isMessageforSend (getFirst s.p) dest count tag datatype}
    ensures { s.p = getNext (old s).p }

val recv (source:int) (count: int) (tag: int) (datatype: mpi_datatype): unit
    writes { s.p }
    requires { 0 <= source /\ source < size }
    requires { isMessageforRecv (getFirst s.p) source count tag datatype}
    ensures { s.p = getNext (old s).p }

val broadcast (root: int) (count: int) (datatype: mpi_datatype): unit
    writes { s.p }
    requires { 0 <= root /\ root < size }
    requires { isforBroadcast (getFirst s.p) root count datatype}
    ensures { s.p = getNext (old s).p }

(*---------------------------------------------------------------------------------------------------*)

val intbroadcast (data: int) (root: int): int
    writes { s.p }
    requires { 0 <= root /\ root < size }
    requires { isforIntBroadcast (getFirst s.p) root data}
    ensures {match getFirst (old s).p with
	       | IntBroadcast _ pred _ -> pred result
	       | _ -> false
	     end}
    ensures {match getFirst (old s).p with
	       | IntBroadcast _ _ prod -> s.p = Seq (prod data) (getNext (old s).p)
	       | _ -> false
	     end}

val intssend (data: int) (dest:int) (tag: int): unit
    writes { s.p }
    requires { 0 <= dest /\ dest < size }
    requires { isMessageforIntSend (getFirst s.p) dest tag data}
    ensures { s.p = getNext (old s).p }

val intrecv (data: int) (source:int) (tag: int): int
    writes { s.p }
    requires { 0 <= source /\ source < size }
    requires { isMessageforIntRecv (getFirst s.p) source tag data}
    ensures { s.p = getNext (old s).p }
    ensures {match getFirst (old s).p with
	       | IntMessage _ _ _ pred -> pred result
	       | _ -> false
	     end}

(*---------------------------------------------------------------------------------------------------*)

val simpl_pro (): unit
    writes {s.p}
    ensures{s.p= simpl (old s).p}

val unroll_pro (): unit
    writes { s.p }
    ensures { s.p = Seq (simpl (getFirst (old s).p)) (getNext (old s).p) }

val assoc_pro (): unit
    writes { s.p }
    ensures { s.p = assoc (old s).p}

val toskip_pro (): unit
    writes { s.p }
    requires { isSkip (simpl (getFirst s.p)) }
    ensures { s.p = getNext (old s).p }

val finalize () : unit
    requires {isSkip (s.p)}

end

module MPI_example

use protocol.MPI_Protocol
use protocol.MPI_Protocol_Handler
use protocol.MPI_prop
use MPI_Function
use int.Int

let test1 () : unit
requires {size >= 2}
=
    init (Message 0 1 1 1 MPI_int);
    if rank = 0 then (
       ssend 1 1 1 MPI_int;
    )
    else if (rank = 1) then (
       recv 0 1 1 MPI_int;
       ()
    )
    else (
      toskip_pro ();
    );
   finalize ()

let test12 () : unit
requires {size >= 2}
=
    init (Foreach 0 0 (fun i -> Message i (i+1) 1 1 MPI_int));
    if rank = 0 then (
       simpl_pro ();
       ssend 1 1 1 MPI_int;
       simpl_pro ();
       simpl_pro ();
   )
    else if (rank = 1) then (
         simpl_pro ();
    	 recv 0 1 1 MPI_int;
	 simpl_pro ();
	 simpl_pro ();
    )
    else (
      simpl_pro ();
      toskip_pro ();
      simpl_pro ();
      simpl_pro ();
    );
   finalize ()

let test13 () : unit
requires {size >= 2}
=
    init (Seq (Message 0 1 1 1 MPI_int)(Message 0 1 1 1 MPI_int));
    if rank = 0 then (
       ssend 1 1 1 MPI_int;
       ssend 1 1 1 MPI_int
    )
    else if (rank = 1) then (
       recv 0 1 1 MPI_int;
       recv 0 1 1 MPI_int
    )
    else (
      toskip_pro ();
      toskip_pro ();
    );
   finalize ()

(*let test2 () : unit
requires {size >= 20}
=
    init p (Foreach 0 9 (fun i -> Message i (i+10) 1 1 MPI_int));
    if rank < 10 then (
       label L1 in
       let ref i = 0 in
       while i < rank do
	   invariant{ getFirst p.p = getNext (split (getFirst (p.p at L1)) i)}
	   invariant{ getNext p.p = getNext (p.p at L1) }
	   invariant{ 0 <= i <= rank}
	   variant {rank - i}
       	   unroll p;
	   assoc p;
       	   toskip p;
	   i <- i+1;
       done;

       unroll p;
       assoc p;
       ssend (rank+10) 1 1 MPI_int p;

       i <- i+1;
       while i <= 9 do
      	   invariant{ getFirst p.p = getNext (split (getFirst (p.p at L1)) i)}
	   invariant{ getNext p.p = getNext (p.p at L1) }
	   invariant{ rank+1 <= i <= 10}
	   variant {9 - i}
       	   unroll p;
	   assoc p;
       	   toskip p;
	   i <- i+1;
       done;
       toskip p;
    )
    else if (rank < 20) then (
       label L1 in
       let ref i = 0 in
       while i < (rank-10) do
	   invariant{ getFirst p.p = getNext (split (getFirst (p.p at L1)) i)}
	   invariant{ getNext p.p = getNext (p.p at L1) }
	   invariant{ 0 <= i <= rank-10}
	   variant { rank-10 - i}
       	   unroll p;
	   assoc p;
       	   toskip p;
	   i <- i+1;
       done;

       unroll p;
       assoc p;
       recv (rank - 10) 1 1 MPI_int p;

       i <- i+1;
       while i <= 9 do
      	   invariant{ getFirst p.p = getNext (split (getFirst (p.p at L1)) i)}
	   invariant{ getNext p.p = getNext (p.p at L1) }
	   invariant{ rank+1 -10 <= i <= 10}
	   variant {9 - i}
       	   unroll p;
	   assoc p;
       	   toskip p;
	   i <- i+1;
       done;
       toskip p;
    )
    else (
       label L1 in
       let ref i = 0 in
       while i <= 9 do
	   invariant{ getFirst p.p = getNext (split (getFirst (p.p at L1)) i)}
	   invariant{ getNext p.p = getNext (p.p at L1) }
	   invariant{ 0 <= i <= 10}
	   variant {9 - i}
       	   unroll p;
	   assoc p;
       	   toskip p;
	   i <- i+1;
       done;
       toskip p;
    );
   finalize p

let test3 () : unit
requires {size >= 10}
=
    init p (While 10 (Message 0 1 1 1 MPI_int));
    if rank = 0 then (
       label L1 in
       let ref i = 0 in
       while i <= 9 do
	   invariant{ getFirst p.p = getNext (split (getFirst (p.p at L1)) i)}
	   invariant{ getNext p.p = getNext (p.p at L1) }
	   invariant{ 0 <= i <= 10}
	   variant {9 - i}

	   unroll p;
       	   assoc p;
	   ssend 1 1 1 MPI_int p;
	   i <- i+1;
       done;
       toskip p;
    )
    else if rank = 1 then (
       label L1 in
       let ref i = 0 in
       while i <= 9 do
       	   invariant{ getFirst p.p = getNext (split (getFirst (p.p at L1)) i)}
       	   invariant{ getNext p.p = getNext (p.p at L1) }
       	   invariant{ 0 <= i <= 10}
       	   variant {9 - i}

       	   unroll p;
       	   assoc p;
           recv 0 1 1 MPI_int p;
       	   i <- i+1;
       	done;
       	toskip p;
    )
    else (
       label L1 in
       let ref i = 0 in
       while i <= 9 do
       	   invariant{ getFirst p.p = getNext (split (getFirst (p.p at L1)) i)}
       	   invariant{ getNext p.p = getNext (p.p at L1) }
       	   invariant{ 0 <= i <= 10}
       	   variant {9 - i}
       	   unroll p;
       	   assoc p;
       	   toskip p;
       	   i <- i+1;
       done;
       toskip p;
    );
   finalize p


(*let test4 () : unit
requires {size >= 2}
=
    init p (Message 0 1 1 1 MPI_int);
    if rank = 0 then (
       intssend 1 1 1 p;
    )
    else if (rank = 1) then (
       intrecv 0 1 1 MPI_int p;
       ()
    )
    else (
      toskip p;
    );
   finalize p

let test42 () : unit
requires {size >= 2}
=
    init p (Foreach 0 0 (fun i -> Message i (i+1) 1 1 MPI_int));
    if rank = 0 then (
       simpl p;
       ssend 1 1 1 MPI_int p;
       simpl p;
       simpl p;
   )
    else if (rank = 1) then (
         simpl p;
    	 recv 0 1 1 MPI_int p;
	 simpl p;
	 simpl p;
    )
    else (
      simpl p;
      toskip p;
      simpl p;
      simpl p;
    );
   finalize p*)
*)
end