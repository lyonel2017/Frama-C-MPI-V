(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require bool.Bool.
Require int.Int.
Require int.Abs.
Require int.EuclideanDivision.
Require int.ComputerDivision.
Require real.Real.
Require real.RealInfix.
Require real.FromInt.
Require map.Map.
Require option.Option.

Parameter eqb:
  forall {a:Type} {a_WT:WhyType a}, a -> a -> Init.Datatypes.bool.

Axiom eqb1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a), ((eqb x y) = Init.Datatypes.true) <-> (x = y).

Axiom eqb_false :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a), ((eqb x y) = Init.Datatypes.false) <-> ~ (x = y).

Parameter neqb:
  forall {a:Type} {a_WT:WhyType a}, a -> a -> Init.Datatypes.bool.

Axiom neqb1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a), ((neqb x y) = Init.Datatypes.true) <-> ~ (x = y).

Parameter zlt: Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Parameter zleq:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom zlt1 :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((zlt x y) = Init.Datatypes.true) <-> (x < y)%Z.

Axiom zleq1 :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((zleq x y) = Init.Datatypes.true) <-> (x <= y)%Z.

Parameter rlt:
  Reals.Rdefinitions.R -> Reals.Rdefinitions.R -> Init.Datatypes.bool.

Parameter rleq:
  Reals.Rdefinitions.R -> Reals.Rdefinitions.R -> Init.Datatypes.bool.

Axiom rlt1 :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R),
  ((rlt x y) = Init.Datatypes.true) <-> (x < y)%R.

Axiom rleq1 :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R),
  ((rleq x y) = Init.Datatypes.true) <-> (x <= y)%R.

(* Why3 assumption *)
Definition real_of_int (x:Numbers.BinNums.Z) : Reals.Rdefinitions.R :=
  BuiltIn.IZR x.

Axiom c_euclidian :
  forall (n:Numbers.BinNums.Z) (d:Numbers.BinNums.Z), ~ (d = 0%Z) ->
  (n = (((ZArith.BinInt.Z.quot n d) * d)%Z + (ZArith.BinInt.Z.rem n d))%Z).

Axiom cmod_remainder :
  forall (n:Numbers.BinNums.Z) (d:Numbers.BinNums.Z),
  ((0%Z <= n)%Z -> (0%Z < d)%Z ->
   (0%Z <= (ZArith.BinInt.Z.rem n d))%Z /\ ((ZArith.BinInt.Z.rem n d) < d)%Z) /\
  ((n <= 0%Z)%Z -> (0%Z < d)%Z ->
   ((-d)%Z < (ZArith.BinInt.Z.rem n d))%Z /\
   ((ZArith.BinInt.Z.rem n d) <= 0%Z)%Z) /\
  ((0%Z <= n)%Z -> (d < 0%Z)%Z ->
   (0%Z <= (ZArith.BinInt.Z.rem n d))%Z /\
   ((ZArith.BinInt.Z.rem n d) < (-d)%Z)%Z) /\
  ((n <= 0%Z)%Z -> (d < 0%Z)%Z ->
   (d < (ZArith.BinInt.Z.rem n d))%Z /\ ((ZArith.BinInt.Z.rem n d) <= 0%Z)%Z).

Axiom cdiv_neutral :
  forall (a:Numbers.BinNums.Z), ((ZArith.BinInt.Z.quot a 1%Z) = a).

Axiom cdiv_inv :
  forall (a:Numbers.BinNums.Z), ~ (a = 0%Z) ->
  ((ZArith.BinInt.Z.quot a a) = 1%Z).

Axiom cdiv_closed_remainder :
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z) (n:Numbers.BinNums.Z),
  (0%Z <= a)%Z -> (0%Z <= b)%Z ->
  (0%Z <= (b - a)%Z)%Z /\ ((b - a)%Z < n)%Z ->
  ((ZArith.BinInt.Z.rem a n) = (ZArith.BinInt.Z.rem b n)) -> (a = b).

(* Why3 assumption *)
Inductive addr :=
  | addr'mk : Numbers.BinNums.Z -> Numbers.BinNums.Z -> addr.
Axiom addr_WhyType : WhyType addr.
Existing Instance addr_WhyType.

(* Why3 assumption *)
Definition offset (v:addr) : Numbers.BinNums.Z :=
  match v with
  | addr'mk x x1 => x1
  end.

(* Why3 assumption *)
Definition base (v:addr) : Numbers.BinNums.Z :=
  match v with
  | addr'mk x x1 => x
  end.

Parameter addr_le: addr -> addr -> Prop.

Parameter addr_lt: addr -> addr -> Prop.

Parameter addr_le_bool: addr -> addr -> Init.Datatypes.bool.

Parameter addr_lt_bool: addr -> addr -> Init.Datatypes.bool.

Axiom addr_le_def :
  forall (p:addr) (q:addr), ((base p) = (base q)) ->
  addr_le p q <-> ((offset p) <= (offset q))%Z.

Axiom addr_lt_def :
  forall (p:addr) (q:addr), ((base p) = (base q)) ->
  addr_lt p q <-> ((offset p) < (offset q))%Z.

Axiom addr_le_bool_def :
  forall (p:addr) (q:addr),
  addr_le p q <-> ((addr_le_bool p q) = Init.Datatypes.true).

Axiom addr_lt_bool_def :
  forall (p:addr) (q:addr),
  addr_lt p q <-> ((addr_lt_bool p q) = Init.Datatypes.true).

(* Why3 assumption *)
Definition null : addr := addr'mk 0%Z 0%Z.

(* Why3 assumption *)
Definition global (b:Numbers.BinNums.Z) : addr := addr'mk b 0%Z.

(* Why3 assumption *)
Definition shift (p:addr) (k:Numbers.BinNums.Z) : addr :=
  addr'mk (base p) ((offset p) + k)%Z.

(* Why3 assumption *)
Definition included (p:addr) (a:Numbers.BinNums.Z) (q:addr)
    (b:Numbers.BinNums.Z) : Prop :=
  (0%Z < a)%Z ->
  (0%Z <= b)%Z /\
  ((base p) = (base q)) /\
  ((offset q) <= (offset p))%Z /\
  (((offset p) + a)%Z <= ((offset q) + b)%Z)%Z.

(* Why3 assumption *)
Definition separated (p:addr) (a:Numbers.BinNums.Z) (q:addr)
    (b:Numbers.BinNums.Z) : Prop :=
  (a <= 0%Z)%Z \/
  (b <= 0%Z)%Z \/
  ~ ((base p) = (base q)) \/
  (((offset q) + b)%Z <= (offset p))%Z \/
  (((offset p) + a)%Z <= (offset q))%Z.

(* Why3 assumption *)
Definition eqmem {a:Type} {a_WT:WhyType a} (m1:addr -> a) (m2:addr -> a)
    (p:addr) (a1:Numbers.BinNums.Z) : Prop :=
  forall (q:addr), included q 1%Z p a1 -> ((m1 q) = (m2 q)).

Parameter havoc:
  forall {a:Type} {a_WT:WhyType a}, (addr -> a) -> (addr -> a) -> addr ->
  Numbers.BinNums.Z -> addr -> a.

(* Why3 assumption *)
Definition valid_rw (m:Numbers.BinNums.Z -> Numbers.BinNums.Z) (p:addr)
    (n:Numbers.BinNums.Z) : Prop :=
  (0%Z < n)%Z ->
  (0%Z < (base p))%Z /\
  (0%Z <= (offset p))%Z /\ (((offset p) + n)%Z <= (m (base p)))%Z.

(* Why3 assumption *)
Definition valid_rd (m:Numbers.BinNums.Z -> Numbers.BinNums.Z) (p:addr)
    (n:Numbers.BinNums.Z) : Prop :=
  (0%Z < n)%Z ->
  ~ (0%Z = (base p)) /\
  (0%Z <= (offset p))%Z /\ (((offset p) + n)%Z <= (m (base p)))%Z.

(* Why3 assumption *)
Definition valid_obj (m:Numbers.BinNums.Z -> Numbers.BinNums.Z) (p:addr)
    (n:Numbers.BinNums.Z) : Prop :=
  (0%Z < n)%Z ->
  (p = null) \/
  ~ (0%Z = (base p)) /\
  (0%Z <= (offset p))%Z /\ (((offset p) + n)%Z <= (1%Z + (m (base p)))%Z)%Z.

(* Why3 assumption *)
Definition invalid (m:Numbers.BinNums.Z -> Numbers.BinNums.Z) (p:addr)
    (n:Numbers.BinNums.Z) : Prop :=
  (n <= 0%Z)%Z \/
  ((base p) = 0%Z) \/
  ((m (base p)) <= (offset p))%Z \/ (((offset p) + n)%Z <= 0%Z)%Z.

Axiom valid_rw_rd :
  forall (m:Numbers.BinNums.Z -> Numbers.BinNums.Z), forall (p:addr),
  forall (n:Numbers.BinNums.Z), valid_rw m p n -> valid_rd m p n.

Axiom valid_string :
  forall (m:Numbers.BinNums.Z -> Numbers.BinNums.Z), forall (p:addr),
  ((base p) < 0%Z)%Z ->
  (0%Z <= (offset p))%Z /\ ((offset p) < (m (base p)))%Z ->
  valid_rd m p 1%Z /\ ~ valid_rw m p 1%Z.

Axiom separated_1 :
  forall (p:addr) (q:addr),
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z) (i:Numbers.BinNums.Z)
    (j:Numbers.BinNums.Z),
  separated p a q b -> ((offset p) <= i)%Z /\ (i < ((offset p) + a)%Z)%Z ->
  ((offset q) <= j)%Z /\ (j < ((offset q) + b)%Z)%Z ->
  ~ ((addr'mk (base p) i) = (addr'mk (base q) j)).

Parameter region: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter linked: (Numbers.BinNums.Z -> Numbers.BinNums.Z) -> Prop.

Parameter sconst: (addr -> Numbers.BinNums.Z) -> Prop.

(* Why3 assumption *)
Definition framed (m:addr -> addr) : Prop :=
  forall (p:addr), ((region (base p)) <= 0%Z)%Z ->
  ((region (base (m p))) <= 0%Z)%Z.

Axiom separated_included :
  forall (p:addr) (q:addr),
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z), (0%Z < a)%Z ->
  (0%Z < b)%Z -> separated p a q b -> ~ included p a q b.

Axiom included_trans :
  forall (p:addr) (q:addr) (r:addr),
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z) (c:Numbers.BinNums.Z),
  included p a q b -> included q b r c -> included p a r c.

Axiom separated_trans :
  forall (p:addr) (q:addr) (r:addr),
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z) (c:Numbers.BinNums.Z),
  included p a q b -> separated q b r c -> separated p a r c.

Axiom separated_sym :
  forall (p:addr) (q:addr),
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z),
  separated p a q b <-> separated q b p a.

Axiom eqmem_included :
  forall {a:Type} {a_WT:WhyType a},
  forall (m1:addr -> a) (m2:addr -> a), forall (p:addr) (q:addr),
  forall (a1:Numbers.BinNums.Z) (b:Numbers.BinNums.Z), included p a1 q b ->
  eqmem m1 m2 q b -> eqmem m1 m2 p a1.

Axiom eqmem_sym :
  forall {a:Type} {a_WT:WhyType a},
  forall (m1:addr -> a) (m2:addr -> a), forall (p:addr),
  forall (a1:Numbers.BinNums.Z), eqmem m1 m2 p a1 -> eqmem m2 m1 p a1.

Axiom havoc_access :
  forall {a:Type} {a_WT:WhyType a},
  forall (m0:addr -> a) (m1:addr -> a), forall (q:addr) (p:addr),
  forall (a1:Numbers.BinNums.Z),
  (separated q 1%Z p a1 -> ((havoc m0 m1 p a1 q) = (m1 q))) /\
  (~ separated q 1%Z p a1 -> ((havoc m0 m1 p a1 q) = (m0 q))).

Parameter cinits: (addr -> Init.Datatypes.bool) -> Prop.

(* Why3 assumption *)
Definition is_init_range (m:addr -> Init.Datatypes.bool) (p:addr)
    (l:Numbers.BinNums.Z) : Prop :=
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < l)%Z ->
  ((m (shift p i)) = Init.Datatypes.true).

Parameter set_init:
  (addr -> Init.Datatypes.bool) -> addr -> Numbers.BinNums.Z ->
  addr -> Init.Datatypes.bool.

Axiom set_init_access :
  forall (m:addr -> Init.Datatypes.bool), forall (q:addr) (p:addr),
  forall (a:Numbers.BinNums.Z),
  (separated q 1%Z p a -> ((set_init m p a q) = (m q))) /\
  (~ separated q 1%Z p a -> ((set_init m p a q) = Init.Datatypes.true)).

(* Why3 assumption *)
Definition monotonic_init (m1:addr -> Init.Datatypes.bool)
    (m2:addr -> Init.Datatypes.bool) : Prop :=
  forall (p:addr), ((m1 p) = Init.Datatypes.true) ->
  ((m2 p) = Init.Datatypes.true).

Parameter int_of_addr: addr -> Numbers.BinNums.Z.

Parameter addr_of_int: Numbers.BinNums.Z -> addr.

Axiom table : Type.
Parameter table_WhyType : WhyType table.
Existing Instance table_WhyType.

Parameter table_of_base: Numbers.BinNums.Z -> table.

Parameter table_to_offset: table -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom table_to_offset_zero :
  forall (t:table), ((table_to_offset t 0%Z) = 0%Z).

Axiom table_to_offset_monotonic :
  forall (t:table), forall (o1:Numbers.BinNums.Z) (o2:Numbers.BinNums.Z),
  (o1 <= o2)%Z <-> ((table_to_offset t o1) <= (table_to_offset t o2))%Z.

Axiom int_of_addr_bijection :
  forall (a:Numbers.BinNums.Z), ((int_of_addr (addr_of_int a)) = a).

Axiom addr_of_int_bijection :
  forall (p:addr), ((addr_of_int (int_of_addr p)) = p).

Axiom addr_of_null : ((int_of_addr null) = 0%Z).

Axiom S15_c_protocol : Type.
Parameter S15_c_protocol_WhyType : WhyType S15_c_protocol.
Existing Instance S15_c_protocol_WhyType.

Axiom list : forall (a:Type), Type.
Parameter list_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (list a).
Existing Instance list_WhyType.

Parameter nil: forall {a:Type} {a_WT:WhyType a}, list a.

Parameter cons: forall {a:Type} {a_WT:WhyType a}, a -> list a -> list a.

Parameter concat:
  forall {a:Type} {a_WT:WhyType a}, list a -> list a -> list a.

Parameter repeat:
  forall {a:Type} {a_WT:WhyType a}, list a -> Numbers.BinNums.Z -> list a.

Parameter length:
  forall {a:Type} {a_WT:WhyType a}, list a -> Numbers.BinNums.Z.

Parameter nth:
  forall {a:Type} {a_WT:WhyType a}, list a -> Numbers.BinNums.Z -> a.

Axiom length_pos :
  forall {a:Type} {a_WT:WhyType a}, forall (w:list a), (0%Z <= (length w))%Z.

Axiom length_nil :
  forall {a:Type} {a_WT:WhyType a}, ((length (nil : list a)) = 0%Z).

Axiom length_nil_bis :
  forall {a:Type} {a_WT:WhyType a},
  forall (w:list a), ((length w) = 0%Z) -> (w = (nil : list a)).

Axiom length_cons :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (w:list a), ((length (cons x w)) = (1%Z + (length w))%Z).

Axiom length_concat :
  forall {a:Type} {a_WT:WhyType a},
  forall (u:list a) (v:list a),
  ((length (concat u v)) = ((length u) + (length v))%Z).

Axiom length_repeat :
  forall {a:Type} {a_WT:WhyType a},
  forall (w:list a) (n:Numbers.BinNums.Z), (0%Z <= n)%Z ->
  ((length (repeat w n)) = (n * (length w))%Z).

Axiom nth_cons :
  forall {a:Type} {a_WT:WhyType a},
  forall (k:Numbers.BinNums.Z) (x:a) (w:list a),
  ((k = 0%Z) -> ((nth (cons x w) k) = x)) /\
  (~ (k = 0%Z) -> ((nth (cons x w) k) = (nth w (k - 1%Z)%Z))).

Axiom nth_concat :
  forall {a:Type} {a_WT:WhyType a},
  forall (u:list a) (v:list a) (k:Numbers.BinNums.Z),
  ((k < (length u))%Z -> ((nth (concat u v) k) = (nth u k))) /\
  (~ (k < (length u))%Z ->
   ((nth (concat u v) k) = (nth v (k - (length u))%Z))).

Axiom nth_repeat :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Numbers.BinNums.Z) (k:Numbers.BinNums.Z) (w:list a),
  (0%Z <= k)%Z /\ (k < (n * (length w))%Z)%Z -> (0%Z < (length w))%Z ->
  ((nth (repeat w n) k) = (nth w (ZArith.BinInt.Z.rem k (length w)))).

(* Why3 assumption *)
Definition vlist_eq {a:Type} {a_WT:WhyType a} (u:list a) (v:list a) : Prop :=
  ((length u) = (length v)) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length u))%Z ->
   ((nth u i) = (nth v i))).

Axiom extensionality :
  forall {a:Type} {a_WT:WhyType a},
  forall (u:list a) (v:list a), vlist_eq u v -> (u = v).

Axiom eq_nil_concat :
  forall {a:Type} {a_WT:WhyType a},
  forall (w:list a),
  vlist_eq (concat (nil : list a) w) w /\
  vlist_eq (concat w (nil : list a)) w.

Axiom rw_nil_concat_left :
  forall {a:Type} {a_WT:WhyType a},
  forall (w:list a), ((concat (nil : list a) w) = w).

Axiom rw_nil_concat_right :
  forall {a:Type} {a_WT:WhyType a},
  forall (w:list a), ((concat w (nil : list a)) = w).

Axiom eq_cons_concat :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (v:list a) (w:list a),
  vlist_eq (concat (cons x v) w) (cons x (concat v w)).

Axiom rw_cons_concat :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (v:list a) (w:list a),
  ((concat (cons x v) w) = (cons x (concat v w))).

Axiom rw_nil_cons_concat :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (w:list a), ((concat (cons x (nil : list a)) w) = (cons x w)).

Axiom eq_assoc_concat :
  forall {a:Type} {a_WT:WhyType a},
  forall (u:list a) (v:list a) (w:list a),
  vlist_eq (concat (concat u v) w) (concat u (concat v w)).

Axiom rw_nil_repeat :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Numbers.BinNums.Z), (0%Z <= n)%Z ->
  ((repeat (nil : list a) n) = (nil : list a)).

Axiom rw_repeat_zero :
  forall {a:Type} {a_WT:WhyType a},
  forall (w:list a), ((repeat w 0%Z) = (nil : list a)).

Axiom eq_repeat_one :
  forall {a:Type} {a_WT:WhyType a},
  forall (w:list a), vlist_eq (repeat w 1%Z) w.

Axiom rw_repeat_one :
  forall {a:Type} {a_WT:WhyType a}, forall (w:list a), ((repeat w 1%Z) = w).

Axiom eq_repeat_concat :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:Numbers.BinNums.Z) (q:Numbers.BinNums.Z) (w:list a),
  (0%Z <= p)%Z -> (0%Z <= q)%Z ->
  vlist_eq (repeat w (p + q)%Z) (concat (repeat w p) (repeat w q)).

Axiom rw_repeat_concat :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:Numbers.BinNums.Z) (q:Numbers.BinNums.Z) (w:list a),
  (0%Z <= p)%Z -> (0%Z <= q)%Z ->
  ((repeat w (p + q)%Z) = (concat (repeat w p) (repeat w q))).

Axiom rw_repeat_after :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:Numbers.BinNums.Z) (w:list a), (0%Z <= p)%Z ->
  ((concat (repeat w p) w) = (repeat w (p + 1%Z)%Z)).

Axiom rw_repeat_before :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:Numbers.BinNums.Z) (w:list a), (0%Z <= p)%Z ->
  ((concat w (repeat w p)) = (repeat w (p + 1%Z)%Z)).

Parameter repeat_box:
  forall {a:Type} {a_WT:WhyType a}, list a -> Numbers.BinNums.Z -> list a.

Axiom rw_repeat_box_unfold :
  forall {a:Type} {a_WT:WhyType a},
  forall (w:list a) (n:Numbers.BinNums.Z), ((repeat_box w n) = (repeat w n)).

Axiom rw_repeat_plus_box_unfold :
  forall {a:Type} {a_WT:WhyType a},
  forall (w:list a) (a1:Numbers.BinNums.Z) (b:Numbers.BinNums.Z),
  (0%Z <= a1)%Z -> (0%Z <= b)%Z ->
  ((repeat_box w (a1 + b)%Z) = (concat (repeat w a1) (repeat w b))).

Axiom rw_repeat_plus_one_box_unfold :
  forall {a:Type} {a_WT:WhyType a},
  forall (w:list a) (n:Numbers.BinNums.Z), (0%Z < n)%Z ->
  ((repeat_box w n) = (concat (repeat w (n - 1%Z)%Z) w)) /\
  ((repeat_box w (n + 1%Z)%Z) = (concat (repeat w n) w)).

(* Why3 assumption *)
Inductive mpi_datatype :=
  | MPI_char : mpi_datatype
  | MPI_int : mpi_datatype
  | MPI_float : mpi_datatype.
Axiom mpi_datatype_WhyType : WhyType mpi_datatype.
Existing Instance mpi_datatype_WhyType.

(* Why3 assumption *)
Inductive mpi_op :=
  | MPI_max : mpi_op
  | MPI_min : mpi_op
  | MPI_sum : mpi_op
  | MPI_prod : mpi_op
  | MPI_land : mpi_op
  | MPI_band : mpi_op
  | MPI_lor : mpi_op
  | MPI_bor : mpi_op
  | MPI_lxor : mpi_op
  | MPI_bxor : mpi_op
  | MPI_maxloc : mpi_op
  | MPI_minloc : mpi_op
  | MPI_replace : mpi_op
  | MPI_no_op : mpi_op.
Axiom mpi_op_WhyType : WhyType mpi_op.
Existing Instance mpi_op_WhyType.

Parameter size: Numbers.BinNums.Z.

(* Why3 assumption *)
Inductive protocol :=
  | IntMessage : Numbers.BinNums.Z -> Numbers.BinNums.Z ->
      Numbers.BinNums.Z -> Numbers.BinNums.Z ->
      (list Numbers.BinNums.Z -> Init.Datatypes.bool) -> protocol
  | IntBroadcast : Numbers.BinNums.Z -> Numbers.BinNums.Z ->
      (list Numbers.BinNums.Z -> Init.Datatypes.bool) ->
      (list Numbers.BinNums.Z -> protocol) -> protocol
  | IntGhostBroadcast : Numbers.BinNums.Z -> Numbers.BinNums.Z ->
      (list Numbers.BinNums.Z -> Init.Datatypes.bool) ->
      (list Numbers.BinNums.Z -> protocol) -> protocol
  | Gather : Numbers.BinNums.Z -> Numbers.BinNums.Z -> mpi_datatype ->
      protocol
  | Scatter : Numbers.BinNums.Z -> Numbers.BinNums.Z -> mpi_datatype ->
      protocol
  | Reduce : Numbers.BinNums.Z -> Numbers.BinNums.Z -> mpi_datatype ->
      mpi_op -> protocol
  | Allgather : Numbers.BinNums.Z -> mpi_datatype -> protocol
  | Allreduce : Numbers.BinNums.Z -> mpi_datatype -> mpi_op -> protocol
  | Foreach : Numbers.BinNums.Z -> Numbers.BinNums.Z ->
      (Numbers.BinNums.Z -> protocol) -> protocol
  | If : Init.Datatypes.bool -> protocol -> protocol -> protocol
  | Seq : protocol -> protocol -> protocol
  | Skip : protocol.
Axiom protocol_WhyType : WhyType protocol.
Existing Instance protocol_WhyType.

Axiom array : forall (a:Type), Type.
Parameter array_WhyType :
  forall (a:Type) {a_WT:WhyType a}, WhyType (array a).
Existing Instance array_WhyType.

Parameter elts:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a.

Parameter length1:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z.

Axiom array'invariant :
  forall {a:Type} {a_WT:WhyType a},
  forall (self:array a), (0%Z <= (length1 self))%Z.

(* Why3 assumption *)
Definition mixfix_lbrb {a:Type} {a_WT:WhyType a} (a1:array a)
    (i:Numbers.BinNums.Z) : a :=
  elts a1 i.

Parameter mixfix_lblsmnrb:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a ->
  array a.

Axiom mixfix_lblsmnrb'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  ((length1 (mixfix_lblsmnrb a1 i v)) = (length1 a1)) /\
  ((elts (mixfix_lblsmnrb a1 i v)) = (map.Map.set (elts a1) i v)).

Parameter make:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z -> a -> array a.

Axiom make_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Numbers.BinNums.Z) (v:a), (0%Z <= n)%Z ->
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < n)%Z ->
   ((mixfix_lbrb (make n v) i) = v)) /\
  ((length1 (make n v)) = n).

Parameter rank: Numbers.BinNums.Z.

Parameter isIntMessage: protocol -> Prop.

Axiom IsIntMessage :
  forall (src:Numbers.BinNums.Z) (dst:Numbers.BinNums.Z)
    (data_size:Numbers.BinNums.Z) (t:Numbers.BinNums.Z)
    (pre:list Numbers.BinNums.Z -> Init.Datatypes.bool),
  isIntMessage (IntMessage src dst data_size t pre).

Parameter isIntBroadcast: protocol -> Prop.

Axiom IsIntBroadcast :
  forall (r:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (pred:list Numbers.BinNums.Z -> Init.Datatypes.bool)
    (cont:list Numbers.BinNums.Z -> protocol),
  isIntBroadcast (IntBroadcast r data_size pred cont).

Parameter isGather: protocol -> Prop.

Axiom IsGather :
  forall (r:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (mt:mpi_datatype),
  isGather (Gather r data_size mt).

Parameter isScatter: protocol -> Prop.

Axiom IsScatter :
  forall (r:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (mt:mpi_datatype),
  isScatter (Scatter r data_size mt).

Parameter isReduce: protocol -> Prop.

Axiom IsReduce :
  forall (r:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (mt:mpi_datatype) (op:mpi_op),
  isReduce (Reduce r data_size mt op).

Parameter isAllgather: protocol -> Prop.

Axiom IsAllgather :
  forall (data_size:Numbers.BinNums.Z) (mt:mpi_datatype),
  isAllgather (Allgather data_size mt).

Parameter isAllreduce: protocol -> Prop.

Axiom IsAllreduce :
  forall (data_size:Numbers.BinNums.Z) (mt:mpi_datatype) (op:mpi_op),
  isAllreduce (Allreduce data_size mt op).

Parameter isForeach: protocol -> Prop.

Axiom IsForeach :
  forall (low:Numbers.BinNums.Z) (high:Numbers.BinNums.Z)
    (body:Numbers.BinNums.Z -> protocol),
  isForeach (Foreach low high body).

Parameter isSkip: protocol -> Prop.

Axiom IsSkip : isSkip Skip.

Parameter isMessageforIntSend:
  protocol -> Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z ->
  list Numbers.BinNums.Z -> Prop.

Axiom isforIntSend :
  forall (dest:Numbers.BinNums.Z) (count:Numbers.BinNums.Z)
    (tag:Numbers.BinNums.Z) (src:Numbers.BinNums.Z) (dst:Numbers.BinNums.Z)
    (data_size:Numbers.BinNums.Z) (t:Numbers.BinNums.Z)
    (data:list Numbers.BinNums.Z)
    (pre:list Numbers.BinNums.Z -> Init.Datatypes.bool),
  (0%Z <= src)%Z /\
  (src < size)%Z /\
  (0%Z <= dst)%Z /\
  (dst < size)%Z /\
  ~ (dst = src) /\
  (src = rank) /\ (dest = dst) /\ (data_size = count) /\ (tag = t) ->
  isMessageforIntSend (IntMessage src dst data_size t pre) dest count tag
  data.

Parameter isPredIntMessage: protocol -> list Numbers.BinNums.Z -> Prop.

Axiom isPredIntMessage1 :
  forall (src:Numbers.BinNums.Z) (dst:Numbers.BinNums.Z)
    (data_size:Numbers.BinNums.Z) (t:Numbers.BinNums.Z)
    (data:list Numbers.BinNums.Z)
    (pre:list Numbers.BinNums.Z -> Init.Datatypes.bool),
  ((pre data) = Init.Datatypes.true) ->
  isPredIntMessage (IntMessage src dst data_size t pre) data.

Parameter isMessageforIntRecv:
  protocol -> Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z ->
  Prop.

Axiom isforIntRecv :
  forall (source:Numbers.BinNums.Z) (count:Numbers.BinNums.Z)
    (tag:Numbers.BinNums.Z) (src:Numbers.BinNums.Z) (dst:Numbers.BinNums.Z)
    (data_size:Numbers.BinNums.Z) (t:Numbers.BinNums.Z)
    (pre:list Numbers.BinNums.Z -> Init.Datatypes.bool),
  (0%Z <= src)%Z /\
  (src < size)%Z /\
  (0%Z <= dst)%Z /\
  (dst < size)%Z /\
  ~ (dst = src) /\
  (src = source) /\ (dst = rank) /\ (data_size = count) /\ (tag = t) ->
  isMessageforIntRecv (IntMessage src dst data_size t pre) source count tag.

Parameter predIntMessage: protocol -> list Numbers.BinNums.Z -> Prop.

Axiom PredIntMessage :
  forall (src:Numbers.BinNums.Z) (dst:Numbers.BinNums.Z)
    (data_size:Numbers.BinNums.Z) (t:Numbers.BinNums.Z)
    (data:list Numbers.BinNums.Z)
    (pre:list Numbers.BinNums.Z -> Init.Datatypes.bool),
  predIntMessage (IntMessage src dst data_size t pre) data ->
  ((pre data) = Init.Datatypes.true).

Parameter isforIntBroadcast:
  protocol -> Numbers.BinNums.Z -> Numbers.BinNums.Z ->
  list Numbers.BinNums.Z -> Prop.

Axiom isIntBroadcast1 :
  forall (root:Numbers.BinNums.Z) (r:Numbers.BinNums.Z)
    (count:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (data:list Numbers.BinNums.Z)
    (pred:list Numbers.BinNums.Z -> Init.Datatypes.bool)
    (cont:list Numbers.BinNums.Z -> protocol),
  (0%Z <= r)%Z /\
  (r < size)%Z /\
  (root = r) /\
  (data_size = count) /\
  ((rank = root) -> ((pred data) = Init.Datatypes.true)) ->
  isforIntBroadcast (IntBroadcast r data_size pred cont) root count data.

Parameter isforIntGhostBroadcast:
  protocol -> Numbers.BinNums.Z -> Numbers.BinNums.Z ->
  list Numbers.BinNums.Z -> Prop.

Axiom isIntGhostBroadcast :
  forall (root:Numbers.BinNums.Z) (r:Numbers.BinNums.Z)
    (count:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (data:list Numbers.BinNums.Z)
    (pred:list Numbers.BinNums.Z -> Init.Datatypes.bool)
    (cont:list Numbers.BinNums.Z -> protocol),
  (0%Z <= r)%Z /\
  (r < size)%Z /\
  (root = r) /\
  (data_size = count) /\
  ((rank = root) -> ((pred data) = Init.Datatypes.true)) ->
  isforIntGhostBroadcast (IntGhostBroadcast r data_size pred cont) root count
  data.

Parameter predIntBroadcast: protocol -> list Numbers.BinNums.Z -> Prop.

Axiom PredIntBroadcast :
  forall (r:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (pred:list Numbers.BinNums.Z -> Init.Datatypes.bool)
    (cont:list Numbers.BinNums.Z -> protocol) (data:list Numbers.BinNums.Z),
  predIntBroadcast (IntBroadcast r data_size pred cont) data ->
  ((pred data) = Init.Datatypes.true).

Axiom PredIntGhostBroadcast :
  forall (r:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (pred:list Numbers.BinNums.Z -> Init.Datatypes.bool)
    (cont:list Numbers.BinNums.Z -> protocol) (data:list Numbers.BinNums.Z),
  predIntBroadcast (IntGhostBroadcast r data_size pred cont) data ->
  ((pred data) = Init.Datatypes.true).

Parameter countiIntBroadcast:
  protocol -> protocol -> protocol -> list Numbers.BinNums.Z -> Prop.

Axiom CountiIntBroadcast :
  forall (r:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (pred:list Numbers.BinNums.Z -> Init.Datatypes.bool)
    (cont:list Numbers.BinNums.Z -> protocol) (data:list Numbers.BinNums.Z)
    (old_n:protocol) (new_p:protocol),
  countiIntBroadcast (IntBroadcast r data_size pred cont) old_n new_p data ->
  (new_p = (Seq (cont data) old_n)).

Axiom CountiIntGhostBroadcast :
  forall (r:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (pred:list Numbers.BinNums.Z -> Init.Datatypes.bool)
    (cont:list Numbers.BinNums.Z -> protocol) (data:list Numbers.BinNums.Z)
    (old_n:protocol) (new_p:protocol),
  countiIntBroadcast (IntGhostBroadcast r data_size pred cont) old_n new_p
  data -> (new_p = (Seq (cont data) old_n)).

Parameter isforGather:
  protocol -> Numbers.BinNums.Z -> Numbers.BinNums.Z -> mpi_datatype -> Prop.

Axiom isGather1 :
  forall (root:Numbers.BinNums.Z) (r:Numbers.BinNums.Z)
    (count:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (datatype:mpi_datatype) (mt:mpi_datatype),
  (0%Z <= r)%Z /\
  (r < size)%Z /\ (root = r) /\ (data_size = count) /\ (datatype = mt) ->
  isforGather (Gather r data_size mt) root count datatype.

Parameter isforScatter:
  protocol -> Numbers.BinNums.Z -> Numbers.BinNums.Z -> mpi_datatype -> Prop.

Axiom isScatter1 :
  forall (root:Numbers.BinNums.Z) (r:Numbers.BinNums.Z)
    (count:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (datatype:mpi_datatype) (mt:mpi_datatype),
  (0%Z <= r)%Z /\
  (r < size)%Z /\ (root = r) /\ (data_size = count) /\ (datatype = mt) ->
  isforScatter (Scatter r data_size mt) root count datatype.

Parameter isforReduce:
  protocol -> Numbers.BinNums.Z -> Numbers.BinNums.Z -> mpi_datatype ->
  mpi_op -> Prop.

Axiom isReduce1 :
  forall (root:Numbers.BinNums.Z) (r:Numbers.BinNums.Z)
    (count:Numbers.BinNums.Z) (data_size:Numbers.BinNums.Z)
    (datatype:mpi_datatype) (mt:mpi_datatype) (op:mpi_op) (opera:mpi_op),
  (0%Z <= r)%Z /\
  (r < size)%Z /\
  (root = r) /\ (data_size = count) /\ (datatype = mt) /\ (opera = op) ->
  isforReduce (Reduce r data_size mt op) root count datatype opera.

Parameter isforAllgather:
  protocol -> Numbers.BinNums.Z -> mpi_datatype -> Prop.

Axiom isAllgather1 :
  forall (data_size:Numbers.BinNums.Z) (count:Numbers.BinNums.Z)
    (datatype:mpi_datatype) (mt:mpi_datatype),
  (data_size = count) /\ (datatype = mt) ->
  isforAllgather (Allgather data_size mt) count datatype.

Parameter isforAllreduce:
  protocol -> Numbers.BinNums.Z -> mpi_datatype -> mpi_op -> Prop.

Axiom isAllreduce1 :
  forall (data_size:Numbers.BinNums.Z) (count:Numbers.BinNums.Z)
    (datatype:mpi_datatype) (mt:mpi_datatype) (op:mpi_op) (opera:mpi_op),
  (data_size = count) /\ (datatype = mt) /\ (opera = op) ->
  isforAllreduce (Allreduce data_size mt op) count datatype opera.

Parameter simpl: protocol -> protocol.

Axiom simpl_seq_1 : forall (p:protocol), ((simpl (Seq Skip p)) = p).

Axiom simpl_seq_2 : forall (p:protocol), ((simpl (Seq p Skip)) = p).

Axiom simp_if_true :
  forall (b:Init.Datatypes.bool) (p1:protocol) (p2:protocol),
  (b = Init.Datatypes.true) -> ((simpl (If b p1 p2)) = p1).

Axiom simp_if_false :
  forall (b:Init.Datatypes.bool) (p1:protocol) (p2:protocol),
  ~ (b = Init.Datatypes.true) -> ((simpl (If b p1 p2)) = p2).

Axiom simpl_intmessage :
  forall (source:Numbers.BinNums.Z) (dest:Numbers.BinNums.Z)
    (data_size:Numbers.BinNums.Z) (tag:Numbers.BinNums.Z)
    (pre:list Numbers.BinNums.Z -> Init.Datatypes.bool),
  (0%Z <= source)%Z /\
  (source < size)%Z /\
  (0%Z <= dest)%Z /\
  (dest < size)%Z /\
  ~ (dest = source) /\ ~ (rank = source) /\ ~ (rank = dest) ->
  ((simpl (IntMessage source dest data_size tag pre)) = Skip).

Axiom simpl_foreach_1 :
  forall (low:Numbers.BinNums.Z) (high:Numbers.BinNums.Z)
    (body:Numbers.BinNums.Z -> protocol),
  (low <= high)%Z ->
  ((simpl (Foreach low high body)) =
   (Seq (body low) (Foreach (low + 1%Z)%Z high body))).

Axiom simpl_foreach_2 :
  forall (low:Numbers.BinNums.Z) (high:Numbers.BinNums.Z)
    (body:Numbers.BinNums.Z -> protocol),
  (high < low)%Z -> ((simpl (Foreach low high body)) = Skip).

Axiom simpl_Skip : ((simpl Skip) = Skip).

Parameter fsimpl: protocol -> protocol.

Axiom fsimpl_foreach :
  forall (low:Numbers.BinNums.Z) (high:Numbers.BinNums.Z)
    (body:Numbers.BinNums.Z -> protocol),
  (forall (i:Numbers.BinNums.Z), (low <= i)%Z /\ (i <= high)%Z ->
   ((simpl (body i)) = Skip)) ->
  ((fsimpl (Foreach low high body)) = Skip).

Parameter split: protocol -> Numbers.BinNums.Z -> protocol.

Axiom split_foreach :
  forall (low:Numbers.BinNums.Z) (high:Numbers.BinNums.Z)
    (c:Numbers.BinNums.Z) (body:Numbers.BinNums.Z -> protocol),
  (low <= c)%Z /\ (c <= high)%Z ->
  ((split (Foreach low high body) c) =
   (Seq (Foreach low (c - 1%Z)%Z body) (Foreach c high body))).

Parameter split_right: protocol -> Numbers.BinNums.Z -> protocol.

Axiom split_right_foreach :
  forall (low:Numbers.BinNums.Z) (high:Numbers.BinNums.Z)
    (c:Numbers.BinNums.Z) (body:Numbers.BinNums.Z -> protocol),
  (low <= high)%Z ->
  ((split_right (Foreach low high body) c) = (Foreach c high body)).

Parameter assoc: protocol -> protocol.

Axiom Assoc :
  forall (h:protocol) (q:protocol) (p:protocol),
  ((assoc (Seq (Seq h q) p)) = (Seq h (Seq q p))).

(* Why3 assumption *)
Definition getLeft (p:protocol) : protocol :=
  match p with
  | Seq h _ => h
  | _ => p
  end.

(* Why3 assumption *)
Definition getRight (p:protocol) : protocol :=
  match p with
  | Seq _ q => q
  | _ => Skip
  end.

Parameter P_set_type: S15_c_protocol -> protocol -> Prop.

Parameter L_get_type: S15_c_protocol -> protocol.

Axiom Q_link :
  forall (p:protocol) (s:S15_c_protocol), P_set_type s p ->
  ((L_get_type s) = p).

(* Why3 assumption *)
Definition f1 (n:Numbers.BinNums.Z) (i:Numbers.BinNums.Z) : protocol :=
  IntMessage 0%Z i (int.EuclideanDivision.div n size) 0%Z
  (fun (us:list Numbers.BinNums.Z) => Init.Datatypes.true).

(* Why3 assumption *)
Definition f2 (i:Numbers.BinNums.Z) : protocol :=
  IntMessage (size - i)%Z ((size - i)%Z - 1%Z)%Z 1%Z 0%Z
  (fun (us:list Numbers.BinNums.Z) => Init.Datatypes.true).

(* Why3 assumption *)
Definition f3 (i:Numbers.BinNums.Z) : protocol :=
  IntMessage i (i + 1%Z)%Z 1%Z 0%Z
  (fun (us:list Numbers.BinNums.Z) => Init.Datatypes.true).

(* Why3 assumption *)
Definition protocol_7 : protocol :=
  Foreach 0%Z (size - 2%Z)%Z (fun (i:Numbers.BinNums.Z) => f3 i).

(* Why3 assumption *)
Definition protocol_6 : protocol :=
  Foreach 1%Z (size - 1%Z)%Z (fun (i:Numbers.BinNums.Z) => f2 i).

(* Why3 assumption *)
Definition protocol_4 (numIter:Numbers.BinNums.Z) : protocol :=
  Foreach 0%Z numIter
  (fun (us:Numbers.BinNums.Z) => Seq protocol_6 protocol_7).

(* Why3 assumption *)
Definition protocol_3 (n:Numbers.BinNums.Z) (numIter:Numbers.BinNums.Z)
    (wstep:Numbers.BinNums.Z) : protocol :=
  Seq (Foreach 1%Z (size - 1%Z)%Z (fun (i:Numbers.BinNums.Z) => f1 n i))
  (protocol_4 numIter).

(* Why3 assumption *)
Definition protocol_2 (n:Numbers.BinNums.Z) (numIter:Numbers.BinNums.Z) :
    protocol :=
  IntBroadcast 0%Z 1%Z
  (fun (us:list Numbers.BinNums.Z) => Init.Datatypes.true)
  (fun (l:list Numbers.BinNums.Z) => protocol_3 n numIter (nth l 0%Z)).

Parameter fc: list Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom fc'def :
  forall (l:list Numbers.BinNums.Z),
  ((fc l) = Init.Datatypes.true) <-> (0%Z < (nth l 0%Z))%Z.

(* Why3 assumption *)
Definition protocol_1 (n:Numbers.BinNums.Z) : protocol :=
  IntBroadcast 0%Z 1%Z fc
  (fun (l:list Numbers.BinNums.Z) => protocol_2 n (nth l 0%Z)).

Parameter fc1: list Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom fc'def1 :
  forall (l:list Numbers.BinNums.Z),
  ((fc1 l) = Init.Datatypes.true) <->
  (0%Z < (nth l 0%Z))%Z /\ ((nth l 0%Z) <= (10000%Z * size)%Z)%Z.

(* Why3 assumption *)
Definition the_protocol : protocol :=
  IntBroadcast 0%Z 1%Z fc1
  (fun (l:list Numbers.BinNums.Z) => protocol_1 (nth l 0%Z)).

Axiom Q_G_mpi_mpi_op_max_33_region : ((region 34%Z) = 0%Z).

Axiom S6_mpi_op_t : Type.
Parameter S6_mpi_op_t_WhyType : WhyType S6_mpi_op_t.
Existing Instance S6_mpi_op_t_WhyType.

Parameter Length_of_S6_mpi_op_t: Numbers.BinNums.Z.

Axiom Q_Positive_Length_of_S6_mpi_op_t : (0%Z < Length_of_S6_mpi_op_t)%Z.

Axiom Q_G_mpi_mpi_op_max_33_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 34%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_min_32_region : ((region 33%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_min_32_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 33%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_sum_34_region : ((region 35%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_sum_34_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 35%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_prod_35_region : ((region 36%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_prod_35_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 36%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_land_36_region : ((region 37%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_land_36_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 37%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_band_37_region : ((region 38%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_band_37_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 38%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_lor_38_region : ((region 39%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_lor_38_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 39%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_bor_39_region : ((region 40%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_bor_39_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 40%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_lxor_40_region : ((region 41%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_lxor_40_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 41%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_bxor_41_region : ((region 42%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_bxor_41_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 42%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_maxloc_42_region : ((region 43%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_maxloc_42_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 43%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_minloc_43_region : ((region 44%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_minloc_43_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 44%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_replace_44_region : ((region 45%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_replace_44_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 45%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_op_no_op_45_region : ((region 46%Z) = 0%Z).

Axiom Q_G_mpi_mpi_op_no_op_45_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 46%Z) = Length_of_S6_mpi_op_t).

Axiom Q_G_mpi_mpi_int_51_region : ((region 52%Z) = 0%Z).

Axiom S2_mpi_datatype_t : Type.
Parameter S2_mpi_datatype_t_WhyType : WhyType S2_mpi_datatype_t.
Existing Instance S2_mpi_datatype_t_WhyType.

Parameter Length_of_S2_mpi_datatype_t: Numbers.BinNums.Z.

Axiom Q_Positive_Length_of_S2_mpi_datatype_t :
  (0%Z < Length_of_S2_mpi_datatype_t)%Z.

Axiom Q_G_mpi_mpi_int_51_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 52%Z) = Length_of_S2_mpi_datatype_t).

Axiom Q_G_mpi_mpi_char_46_region : ((region 47%Z) = 0%Z).

Axiom Q_G_mpi_mpi_char_46_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 47%Z) = Length_of_S2_mpi_datatype_t).

Axiom Q_G_mpi_mpi_float_57_region : ((region 58%Z) = 0%Z).

Axiom Q_G_mpi_mpi_float_57_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 58%Z) = Length_of_S2_mpi_datatype_t).

Axiom Q_L_buf_604_region : ((region 605%Z) = 2%Z).

Axiom Q_L_buf_604_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 605%Z) = 0%Z).

Axiom Q_L_numIter_594_region : ((region 595%Z) = 2%Z).

Axiom Q_L_numIter_594_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 595%Z) = 0%Z).

Axiom Q_L_u_602_region : ((region 603%Z) = 2%Z).

Axiom Q_L_u_602_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 603%Z) = 0%Z).

Axiom Q_L_wstep_595_region : ((region 596%Z) = 2%Z).

Axiom Q_L_wstep_595_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 596%Z) = 0%Z).

Axiom Q_L_n_592_region : ((region 593%Z) = 2%Z).

Axiom Q_L_n_592_linked :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z), linked t ->
  ((t 593%Z) = 0%Z).

(* Why3 assumption *)
Definition size_constrain (s:Numbers.BinNums.Z) : Prop :=
  (1%Z < s)%Z /\ (s <= 10000%Z)%Z.

(* Why3 assumption *)
Definition is_bool (x:Numbers.BinNums.Z) : Prop := (x = 0%Z) \/ (x = 1%Z).

(* Why3 assumption *)
Definition is_uint8 (x:Numbers.BinNums.Z) : Prop :=
  (0%Z <= x)%Z /\ (x < 256%Z)%Z.

(* Why3 assumption *)
Definition is_sint8 (x:Numbers.BinNums.Z) : Prop :=
  ((-128%Z)%Z <= x)%Z /\ (x < 128%Z)%Z.

(* Why3 assumption *)
Definition is_uint16 (x:Numbers.BinNums.Z) : Prop :=
  (0%Z <= x)%Z /\ (x < 65536%Z)%Z.

(* Why3 assumption *)
Definition is_sint16 (x:Numbers.BinNums.Z) : Prop :=
  ((-32768%Z)%Z <= x)%Z /\ (x < 32768%Z)%Z.

(* Why3 assumption *)
Definition is_uint32 (x:Numbers.BinNums.Z) : Prop :=
  (0%Z <= x)%Z /\ (x < 4294967296%Z)%Z.

(* Why3 assumption *)
Definition is_sint32 (x:Numbers.BinNums.Z) : Prop :=
  ((-2147483648%Z)%Z <= x)%Z /\ (x < 2147483648%Z)%Z.

(* Why3 assumption *)
Definition is_uint64 (x:Numbers.BinNums.Z) : Prop :=
  (0%Z <= x)%Z /\ (x < 18446744073709551616%Z)%Z.

(* Why3 assumption *)
Definition is_sint64 (x:Numbers.BinNums.Z) : Prop :=
  ((-9223372036854775808%Z)%Z <= x)%Z /\ (x < 9223372036854775808%Z)%Z.

Axiom is_bool0 : is_bool 0%Z.

Axiom is_bool1 : is_bool 1%Z.

Parameter to_bool: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom to_bool'def :
  forall (x:Numbers.BinNums.Z),
  ((x = 0%Z) -> ((to_bool x) = 0%Z)) /\ (~ (x = 0%Z) -> ((to_bool x) = 1%Z)).

Parameter to_uint8: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_sint8: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_uint16: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_sint16: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_uint32: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_sint32: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_uint64: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_sint64: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter two_power_abs: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom two_power_abs_is_positive :
  forall (n:Numbers.BinNums.Z), (0%Z < (two_power_abs n))%Z.

Axiom two_power_abs_plus_pos :
  forall (n:Numbers.BinNums.Z) (m:Numbers.BinNums.Z), (0%Z <= n)%Z ->
  (0%Z <= m)%Z ->
  ((two_power_abs (n + m)%Z) = ((two_power_abs n) * (two_power_abs m))%Z).

Axiom two_power_abs_plus_one :
  forall (n:Numbers.BinNums.Z), (0%Z <= n)%Z ->
  ((two_power_abs (n + 1%Z)%Z) = (2%Z * (two_power_abs n))%Z).

(* Why3 assumption *)
Definition is_uint (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) : Prop :=
  (0%Z <= x)%Z /\ (x < (two_power_abs n))%Z.

(* Why3 assumption *)
Definition is_sint (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) : Prop :=
  ((-(two_power_abs n))%Z <= x)%Z /\ (x < (two_power_abs n))%Z.

Parameter to_uint:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_sint:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom is_to_uint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z), is_uint n (to_uint n x).

Axiom is_to_sint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z), is_sint n (to_sint n x).

Axiom is_to_uint8 : forall (x:Numbers.BinNums.Z), is_uint8 (to_uint8 x).

Axiom is_to_sint8 : forall (x:Numbers.BinNums.Z), is_sint8 (to_sint8 x).

Axiom is_to_uint16 : forall (x:Numbers.BinNums.Z), is_uint16 (to_uint16 x).

Axiom is_to_sint16 : forall (x:Numbers.BinNums.Z), is_sint16 (to_sint16 x).

Axiom is_to_uint32 : forall (x:Numbers.BinNums.Z), is_uint32 (to_uint32 x).

Axiom is_to_sint32 : forall (x:Numbers.BinNums.Z), is_sint32 (to_sint32 x).

Axiom is_to_uint64 : forall (x:Numbers.BinNums.Z), is_uint64 (to_uint64 x).

Axiom is_to_sint64 : forall (x:Numbers.BinNums.Z), is_sint64 (to_sint64 x).

Axiom id_uint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  is_uint n x <-> ((to_uint n x) = x).

Axiom id_sint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  is_sint n x <-> ((to_sint n x) = x).

Axiom id_uint8 :
  forall (x:Numbers.BinNums.Z), is_uint8 x -> ((to_uint8 x) = x).

Axiom id_sint8 :
  forall (x:Numbers.BinNums.Z), is_sint8 x -> ((to_sint8 x) = x).

Axiom id_uint16 :
  forall (x:Numbers.BinNums.Z), is_uint16 x -> ((to_uint16 x) = x).

Axiom id_sint16 :
  forall (x:Numbers.BinNums.Z), is_sint16 x -> ((to_sint16 x) = x).

Axiom id_uint32 :
  forall (x:Numbers.BinNums.Z), is_uint32 x -> ((to_uint32 x) = x).

Axiom id_sint32 :
  forall (x:Numbers.BinNums.Z), is_sint32 x -> ((to_sint32 x) = x).

Axiom id_uint64 :
  forall (x:Numbers.BinNums.Z), is_uint64 x -> ((to_uint64 x) = x).

Axiom id_sint64 :
  forall (x:Numbers.BinNums.Z), is_sint64 x -> ((to_sint64 x) = x).

Axiom proj_uint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  ((to_uint n (to_uint n x)) = (to_uint n x)).

Axiom proj_sint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  ((to_sint n (to_sint n x)) = (to_sint n x)).

Axiom proj_uint8 :
  forall (x:Numbers.BinNums.Z), ((to_uint8 (to_uint8 x)) = (to_uint8 x)).

Axiom proj_sint8 :
  forall (x:Numbers.BinNums.Z), ((to_sint8 (to_sint8 x)) = (to_sint8 x)).

Axiom proj_uint16 :
  forall (x:Numbers.BinNums.Z), ((to_uint16 (to_uint16 x)) = (to_uint16 x)).

Axiom proj_sint16 :
  forall (x:Numbers.BinNums.Z), ((to_sint16 (to_sint16 x)) = (to_sint16 x)).

Axiom proj_uint32 :
  forall (x:Numbers.BinNums.Z), ((to_uint32 (to_uint32 x)) = (to_uint32 x)).

Axiom proj_sint32 :
  forall (x:Numbers.BinNums.Z), ((to_sint32 (to_sint32 x)) = (to_sint32 x)).

Axiom proj_uint64 :
  forall (x:Numbers.BinNums.Z), ((to_uint64 (to_uint64 x)) = (to_uint64 x)).

Axiom proj_sint64 :
  forall (x:Numbers.BinNums.Z), ((to_sint64 (to_sint64 x)) = (to_sint64 x)).

Axiom proj_su :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  ((to_sint n (to_uint n x)) = (to_uint n x)).

Axiom incl_su :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z), is_uint n x ->
  is_sint n x.

Axiom proj_su_uint :
  forall (n:Numbers.BinNums.Z) (m:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((to_sint (m + n)%Z (to_uint n x)) = (to_uint n x)).

Axiom proj_su_sint :
  forall (n:Numbers.BinNums.Z) (m:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((to_sint n (to_uint (m + (n + 1%Z)%Z)%Z x)) = (to_sint n x)).

Axiom proj_int8 :
  forall (x:Numbers.BinNums.Z), ((to_sint8 (to_uint8 x)) = (to_sint8 x)).

Axiom proj_int16 :
  forall (x:Numbers.BinNums.Z), ((to_sint16 (to_uint16 x)) = (to_sint16 x)).

Axiom proj_int32 :
  forall (x:Numbers.BinNums.Z), ((to_sint32 (to_uint32 x)) = (to_sint32 x)).

Axiom proj_int64 :
  forall (x:Numbers.BinNums.Z), ((to_sint64 (to_uint64 x)) = (to_sint64 x)).

Axiom proj_us_uint :
  forall (n:Numbers.BinNums.Z) (m:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((to_uint (n + 1%Z)%Z (to_sint (m + n)%Z x)) = (to_uint (n + 1%Z)%Z x)).

Axiom incl_uint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= i)%Z -> is_uint n x -> is_uint (n + i)%Z x.

Axiom incl_sint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= i)%Z -> is_sint n x -> is_sint (n + i)%Z x.

Axiom incl_int :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= i)%Z -> is_uint n x -> is_sint (n + i)%Z x.

Parameter L_to_list:
  (addr -> Numbers.BinNums.Z) -> addr -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> list Numbers.BinNums.Z.

Axiom Q_to_list_empty :
  forall (Mint:addr -> Numbers.BinNums.Z) (a:addr) (i:Numbers.BinNums.Z)
    (n:Numbers.BinNums.Z),
  (n <= i)%Z -> ((L_to_list Mint a i n) = (nil : list Numbers.BinNums.Z)).

Axiom Q_to_list_cons :
  forall (Mint:addr -> Numbers.BinNums.Z) (a:addr) (i:Numbers.BinNums.Z)
    (n:Numbers.BinNums.Z),
  let x := ((-1%Z)%Z + n)%Z in
  (i < n)%Z ->
  ((L_to_list Mint a i n) =
   (concat (L_to_list Mint a i x)
    (cons (Mint (shift a x)) (nil : list Numbers.BinNums.Z)))).

Axiom Q_to_list_length :
  forall (Mint:addr -> Numbers.BinNums.Z) (a:addr) (i:Numbers.BinNums.Z)
    (n:Numbers.BinNums.Z),
  (i <= n)%Z -> ((i + (length (L_to_list Mint a i n)))%Z = n).

Axiom Q_to_list_concat :
  forall (Mint:addr -> Numbers.BinNums.Z) (a:addr) (i:Numbers.BinNums.Z)
    (k:Numbers.BinNums.Z) (n:Numbers.BinNums.Z),
  (i <= k)%Z -> (k <= n)%Z ->
  ((L_to_list Mint a i n) =
   (concat (L_to_list Mint a i k) (L_to_list Mint a k n))).

Axiom Q_to_list_nth :
  forall (Mint:addr -> Numbers.BinNums.Z) (a:addr) (i:Numbers.BinNums.Z)
    (n:Numbers.BinNums.Z) (k:Numbers.BinNums.Z),
  let x := (i + k)%Z in
  (i < n)%Z -> (0%Z <= k)%Z -> (x < n)%Z ->
  ((Mint (shift a x)) = (nth (L_to_list Mint a i n) k)).

Axiom Q_to_list_nth_shift :
  forall (Mint:addr -> Numbers.BinNums.Z) (a:addr) (i:Numbers.BinNums.Z)
    (n:Numbers.BinNums.Z) (k:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (i < n)%Z -> (0%Z <= k)%Z -> ((i + k)%Z < n)%Z ->
  ((Mint (shift a ((i + j)%Z + k)%Z)) =
   (nth (L_to_list Mint (shift a j) i n) k)).

(* Why3 goal *)
Theorem wp_goal :
  let x := (1%Z + rank)%Z in
  let a := global 593%Z in
  let a1 := global 595%Z in
  let a2 := global 596%Z in
  let x1 := ((-1%Z)%Z + rank)%Z in
  let a3 := global 603%Z in
  let a4 := shift a3 1%Z in
  forall (t:addr -> Numbers.BinNums.Z) (t1:addr -> Numbers.BinNums.Z)
    (t2:addr -> Numbers.BinNums.Z) (t3:addr -> Numbers.BinNums.Z)
    (t4:addr -> Numbers.BinNums.Z) (t5:addr -> Numbers.BinNums.Z)
    (i:Numbers.BinNums.Z) (c:S15_c_protocol) (c1:S15_c_protocol)
    (c2:S15_c_protocol) (c3:S15_c_protocol) (c4:S15_c_protocol)
    (c5:S15_c_protocol) (c6:S15_c_protocol) (c7:S15_c_protocol)
    (c8:S15_c_protocol) (c9:S15_c_protocol) (c10:S15_c_protocol)
    (c11:S15_c_protocol) (c12:S15_c_protocol) (c13:S15_c_protocol)
    (c14:S15_c_protocol) (c15:S15_c_protocol) (c16:S15_c_protocol)
    (c17:S15_c_protocol) (c18:S15_c_protocol) (c19:S15_c_protocol)
    (c20:S15_c_protocol) (c21:S15_c_protocol) (c22:S15_c_protocol)
    (c23:S15_c_protocol) (c24:S15_c_protocol) (c25:S15_c_protocol)
    (c26:S15_c_protocol) (c27:S15_c_protocol) (c28:S15_c_protocol)
    (c29:S15_c_protocol) (c30:S15_c_protocol) (c31:S15_c_protocol)
    (c32:S15_c_protocol) (t6:Numbers.BinNums.Z -> Numbers.BinNums.Z)
    (t7:Numbers.BinNums.Z -> Numbers.BinNums.Z) (i1:Numbers.BinNums.Z)
    (i2:Numbers.BinNums.Z),
  let a5 := L_get_type c16 in
  let a6 := L_get_type c6 in
  let a7 := L_get_type c19 in
  let a8 := getRight a7 in
  let a9 := L_get_type c in
  let a10 := getRight a9 in
  let x2 := t5 a in
  let a11 := L_get_type c30 in
  let x3 := t4 a1 in
  let a12 := getRight a5 in
  let a13 := getRight a6 in
  let a14 := L_get_type c28 in
  let a15 := getLeft a9 in
  let a16 := getLeft a7 in
  let a17 := split_right a15 (1%Z + i)%Z in
  let x4 := t3 a2 in
  let a18 := L_get_type c26 in
  let a19 := getRight a12 in
  let x5 := ZArith.BinInt.Z.quot x2 size in
  let a20 := L_get_type c31 in
  let a21 := L_get_type c29 in
  let a22 := L_get_type c27 in
  let a23 := L_get_type c24 in
  let a24 := L_get_type c21 in
  let a25 := L_get_type c14 in
  let a26 := L_get_type c11 in
  let a27 := L_get_type c8 in
  let a28 := L_get_type c7 in
  let a29 := L_get_type c4 in
  let a30 := L_get_type c20 in
  let a31 := getLeft a26 in
  let a32 := getLeft a24 in
  let a33 := L_get_type c32 in
  let a34 := getLeft a33 in
  let a35 := L_get_type c23 in
  let a36 := L_get_type c13 in
  let a37 := L_get_type c10 in
  let a38 := L_get_type c3 in
  let a39 := havoc t5 t (shift a 0%Z) 1%Z in
  let a40 := L_to_list a39 a 0%Z 1%Z in
  let a41 := getLeft a11 in
  let a42 := havoc t4 a39 (shift a1 0%Z) 1%Z in
  let a43 := L_to_list a42 a1 0%Z 1%Z in
  let a44 := getLeft a14 in
  let a45 := havoc t3 a42 (shift a2 0%Z) 1%Z in
  let a46 := L_to_list a45 a2 0%Z 1%Z in
  let a47 := havoc t2 a45 a4 x5 in
  let a48 := shift a3 (1%Z + x5)%Z in
  let a49 :=
  havoc t1 (map.Map.set (map.Map.set a47 (shift a3 0%Z) i2) a48 i1) a48 1%Z in
  let a50 := getLeft a27 in
  let a51 := L_to_list a49 a4 0%Z 1%Z in
  ~ (rank = 0%Z) -> ~ (x = size) -> ((getLeft a5) = protocol_6) ->
  ((getLeft a6) = protocol_7) -> (a8 = a10) -> ((protocol_1 x2) = a11) ->
  ((protocol_4 x3) = a9) -> ((getLeft a12) = protocol_7) ->
  ((getRight a13) = a10) -> ((protocol_2 x2 x3) = a14) ->
  ((split_right a15 0%Z) = a15) -> ((split_right a15 i) = a16) ->
  (a17 = (getLeft a13)) -> ((protocol_3 x2 x3 x4) = a18) ->
  ((getLeft a19) = a17) -> ((getRight a19) = a10) -> (0%Z < size)%Z ->
  (0%Z < rank)%Z -> (0%Z <= i)%Z -> (rank <= size)%Z -> (0%Z <= rank)%Z ->
  (rank < size)%Z -> (i < x3)%Z -> (0%Z <= x3)%Z -> (i <= x3)%Z ->
  (0%Z <= x5)%Z -> ((-1%Z)%Z <= rank)%Z -> ((2%Z + rank)%Z <= size)%Z ->
  ((-1%Z)%Z <= x5)%Z -> (x5 <= 10000%Z)%Z -> size_constrain size ->
  is_sint32 i -> is_sint32 size -> is_sint32 rank ->
  P_set_type c32 the_protocol -> is_sint32 x1 -> is_sint32 x ->
  is_sint32 x2 -> is_sint32 x3 -> is_sint32 x4 -> is_sint32 x5 ->
  P_set_type c30 (simpl a20) -> P_set_type c28 (simpl a21) ->
  P_set_type c26 (simpl a22) -> P_set_type c24 (assoc (L_get_type c25)) ->
  P_set_type c23 (getRight a23) -> P_set_type c21 (assoc (L_get_type c22)) ->
  P_set_type c20 (getRight a24) -> P_set_type c17 (assoc (L_get_type c18)) ->
  P_set_type c16 (assoc (L_get_type c17)) ->
  P_set_type c14 (assoc (L_get_type c15)) -> P_set_type c13 (getRight a25) ->
  P_set_type c11 (assoc (L_get_type c12)) -> P_set_type c10 (getRight a26) ->
  P_set_type c8 (assoc (L_get_type c9)) -> P_set_type c7 (getRight a27) ->
  P_set_type c6 (getRight a28) -> P_set_type c4 (assoc (L_get_type c5)) ->
  P_set_type c3 (getRight a29) -> P_set_type c1 (assoc (L_get_type c2)) ->
  P_set_type c (getRight a30) -> isSkip (fsimpl (getLeft a23)) ->
  isSkip (fsimpl (getLeft a30)) -> isSkip (fsimpl (getLeft a25)) ->
  isSkip (fsimpl (getLeft a28)) -> isSkip (fsimpl (getLeft a29)) ->
  isMessageforIntRecv a31 x 1%Z 0%Z -> isMessageforIntRecv a32 0%Z x5 0%Z ->
  isforIntBroadcast a34 0%Z 1%Z (L_to_list t a 0%Z 1%Z) ->
  P_set_type c22 (Seq (simpl (getLeft a35)) (getRight a35)) ->
  P_set_type c18 (Seq (simpl a16) a8) ->
  P_set_type c12 (Seq (simpl (getLeft a36)) (getRight a36)) ->
  P_set_type c9 (Seq (simpl (getLeft a37)) (getRight a37)) ->
  P_set_type c5 (Seq (split protocol_7 x1) a13) ->
  P_set_type c2 (Seq (simpl (getLeft a38)) (getRight a38)) ->
  P_set_type c25 (Seq (split (getLeft a18) rank) (getRight a18)) ->
  P_set_type c15
  (Seq (split protocol_6 (((-1%Z)%Z + size)%Z + ((-1%Z)%Z * rank)%Z)%Z) a12) ->
  predIntBroadcast a34 a40 ->
  isforIntBroadcast a41 0%Z 1%Z (L_to_list a39 a1 0%Z 1%Z) ->
  countiIntBroadcast a34 (getRight a33) a20 a40 ->
  predIntBroadcast a41 a43 ->
  isforIntBroadcast a44 0%Z 1%Z (L_to_list a42 a2 0%Z 1%Z) ->
  countiIntBroadcast a41 (getRight a11) a21 a43 ->
  predIntBroadcast a44 a46 ->
  countiIntBroadcast a44 (getRight a14) a22 a46 ->
  predIntMessage a32 (L_to_list a47 a4 0%Z x5) ->
  predIntMessage a31 (L_to_list a49 a48 0%Z 1%Z) ->
  isPredIntMessage a50 a51 -> isMessageforIntSend a50 x1 1%Z 0%Z a51 ->
  ((0%Z < x5)%Z -> (x5 <= 10001%Z)%Z) ->
  (forall (i3:Numbers.BinNums.Z), (0%Z <= i3)%Z -> (i3 <= 10001%Z)%Z ->
   (i3 < 0%Z)%Z \/ (x5 <= i3)%Z -> ((t7 i3) = (t6 i3))) ->
  isMessageforIntRecv (getLeft (L_get_type c1)) x1 1%Z 0%Z.
Proof.
intros x a a1 a2 x1 a3 a4 t t1 t2 t3 t4 t5 i c c1 c2 c3 c4 c5 c6 c7 c8 c9 c10
c11 c12 c13 c14 c15 c16 c17 c18 c19 c20 c21 c22 c23 c24 c25 c26 c27 c28 c29
c30 c31 c32 t6 t7 i1 i2 a5 a6 a7 a8 a9 a10 x2 a11 x3 a12 a13 a14 a15 a16 a17
x4 a18 a19 x5 a20 a21 a22 a23 a24 a25 a26 a27 a28 a29 a30 a31 a32 a33 a34 a35
a36 a37 a38 a39 a40 a41 a42 a43 a44 a45 a46 a47 a48 a49 a50 a51 h1 h2 h3 h4
h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24
h25 h26 h27 h28 h29 h30 h31 h32 h33 h34 h35 h36 h37 h38 h39 h40 h41 h42 h43
h44 h45 h46 h47 h48 h49 h50 h51 h52 h53 h54 h55 h56 h57 h58 h59 h60 h61 h62
h63 h64 h65 h66 h67 h68 h69 h70 h71 h72 h73 h74 h75 h76 h77 h78 h79 h80 h81
h82 h83 h84 h85 h86 h87 h88 h89 h90 h91.
erewrite Q_link by apply h60.
erewrite Q_link by apply h75.
replace (getLeft a38) with (getLeft (L_get_type c3)) ;[ | unfold a38;reflexivity].
erewrite Q_link by apply h59.
unfold a29.
Search c4.
erewrite Q_link by apply h58.
erewrite Q_link by apply h74.
unfold protocol_7.
rewrite split_foreach by Lia.lia.
rewrite Assoc.
simpl.
rewrite simpl_foreach_1 by Lia.lia.
rewrite Assoc.
simpl.
apply isforIntRecv.
Lia.lia.
Qed.

