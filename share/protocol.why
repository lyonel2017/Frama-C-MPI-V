(**************************************************************************)
(*  This file is part of MPI-V plug-in of Frama-C.                        *)
(*                                                                        *)
(*  Copyright (C) 2020 Lionel Blatter                                     *)
(*                                                                        *)
(*  Lionel Blatter <lionel.blatter@kit.edu>                               *)
(*                                                                        *)
(*  you can redistribute it and/or modify it under the terms of the GNU   *)
(*  Lesser General Public License as published by the Free Software       *)
(*  Foundation, version 2.1.                                              *)
(*                                                                        *)
(*  It is distributed in the hope that it will be useful,                 *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *)
(*  GNU Lesser General Public License for more details.                   *)
(*                                                                        *)
(*  See the GNU Lesser General Public License version 2.1                 *)
(*  for more details (enclosed in the file LICENSE).                      *)
(**************************************************************************)

module MPI_Protocol
use frama_c_wp.vlist.Vlist
(*use list.List*)

type mpi_datatype =
| MPI_char
| MPI_int

val constant size : int

type protocol =
  | IntMessage int int int int (list int -> bool)
    (* ++ the size, sender and recever can go into the predicate*)
  | IntBroadcast int int (list int -> bool) (list int  -> protocol)
    (* ++ the size and the root can go into the predicate and the continuation*)
  | IntGhostBroadcast int int (list int -> bool) (list int  -> protocol)
  | If bool protocol protocol
  | Gather int int mpi_datatype
  | Scatter int int mpi_datatype
  | Foreach int int (int -> protocol)
  | While int protocol
  | Seq protocol protocol
  | Skip
end

module MPI_Protocol_Handler
use int.Int
use option.Option
use array.Array
use MPI_Protocol
use frama_c_wp.vlist.Vlist
(*use list.List*)

val constant rank : int

predicate isIntMessage (p:protocol) =
       match p with
       | IntMessage _ _ _ _ _ -> true
       | _ -> false
       end

predicate isIntBroadcast (p: protocol) =
      match p with
      | IntBroadcast _ _ _ _ -> true
      | _ -> false
      end

predicate isGather (p: protocol) =
       match p with
      | Gather _ _ _ -> true
      | _ -> false
      end

predicate isScatter (p: protocol) =
      match p with
      | Scatter _ _ _ -> true
      | _ -> false
      end

predicate isForeach (p:protocol) =
       match p with
       | Foreach _ _ _ -> true
       | _ -> false
       end

predicate isSkip (p:protocol) =
       match p with
       | Skip -> true
       | _ -> false
       end

predicate isMessageforIntSend (p:protocol) (dest: int) (count: int) (tag: int) (data: list int) =
       match p with
         | IntMessage src dst data_size t pre ->
                   src = rank /\ dest = dst /\ data_size = count /\ tag = t /\
                  (*lenght data = count -> *) pre data /\
                   0 <= src /\ src < size /\ 0 <= dst /\ dst < size /\ dst <> src
         | _ -> false
       end

predicate isMessageforIntRecv (p:protocol) (source: int) (count: int) (tag: int) =
       match p with
         | IntMessage src dst data_size t _ ->
                   src = source /\ dst = rank /\ data_size = count /\ tag = t /\
                   0 <= src /\ src < size /\ 0 <= dst /\ dst < size /\ dst <> src
         | _ -> false
       end

predicate isforIntBroadcast (p: protocol) (root: int) (count: int) (data: list int) =
       match p with
       | IntBroadcast r data_size pred _ -> root = r /\  data_size = count /\
                       ( (*lenght data = count -> *) rank = root -> pred data)
       | _ -> false
       end

predicate isforIntGhostBroadcast (p: protocol) (root: int) (count: int) (data: list int) =
       match p with
       | IntGhostBroadcast r data_size pred _ -> root = r /\  data_size = count /\
                       ( (*lenght data = count -> *) rank = root -> pred data)
       | _ -> false
       end

predicate isforGather (p: protocol) (root: int) (count: int) (datatype: mpi_datatype) =
        match p with
        | Gather r data_size mt -> root = r /\  data_size = count /\ datatype = mt /\
                                   0 <= r /\ r < size
        | _ -> false
        end

predicate isforScatter (p: protocol) (root: int) (count: int) (datatype: mpi_datatype) =
        match p with
        | Scatter r data_size mt -> root = r /\  data_size = count /\ datatype = mt /\
                                    0 <= r /\ r < size
        | _ -> false
        end


(*define specific simpl function for each constructor to speed up proof and potentially as axiom not function*)
(* add meta instruction for speed up proof: unfold and simpl *)
function simpl (p: protocol) : protocol =
         match p with
         | Seq Skip q -> q
         | Seq h Skip -> h
         | If b p1 p2 -> if b then p1 else p2
         | IntMessage source dest _ _ _ ->
            if rank <> source /\ rank <> dest /\
               0 <= source /\ source < size /\ 0 <= dest /\ dest < size /\ dest <> source
            then Skip
            else p
         | Foreach low high body ->
            if low <= high
            then Seq (body low) (Foreach (low + 1) high body)
            else Skip
         | While n body ->
            if n > 0
            then Seq body (While (n-1) body)
            else Skip
         | _ -> p
         end

function split (p: protocol) (c : int): protocol  =
        match p with
       | Foreach low high body ->
         if low <= c <= high
         then Seq (Foreach low (c-1) body) (Foreach c high body)
         else if low <= high < c
              then Seq (Foreach low high body) (Foreach c high body)
              else if c < low <= high
                   then Seq (Foreach low c body) (Foreach low high body)
                   else p
       | While n body ->
         if 0 <= c <= n
         then Seq (While c body) (While (n-c) body)
         else if 0 <= n < c
              then Seq (While n body) (While (n-c) body)
              else if c < 0 <= n
                   then Seq (While c body) (While n body)
                   else p
       | If b p1 p2 ->
         if b then p1 else p2
       | _ -> p
        end

function assoc (p:protocol) :protocol =
         match p with
         | Seq (Seq h q) p -> Seq h (Seq q p)
         | p -> p
         end

let rec function getFirst (p: protocol) : protocol variant {p} =
        match p with
        | Seq h _ -> getFirst h
        | p -> p
        end

let rec function aux (p: protocol) : option protocol variant {p} =
          match p with
          | Seq h q ->
                   match (aux h) with
                   | None -> Some q
                   | Some p ->  Some (Seq p q)
                   end
          | _ -> None
          end

let function getNext (p: protocol): protocol =
        match aux p with
        | None -> Skip
        | Some p -> p
        end

function seq (p1: protocol) (p2: protocol): protocol = Seq p1 p2

predicate predIntMessage (p: protocol) (data: list int) =
            match p with
               | IntMessage _ _ _ _ pred -> pred data
               | _ -> false
             end

predicate predIntBroadcast (p: protocol) (data: list int) =
            match p with
               | IntBroadcast _ _ pred _ -> pred data
               | IntGhostBroadcast _ _ pred _ -> pred data
               | _ -> false
             end

predicate countiIntBroadcast (old_p: protocol) (new_p: protocol) (data: list int) =
           match getFirst old_p with
               | IntBroadcast _ _ _ prod -> new_p = Seq (prod data) (getNext old_p)
               | IntGhostBroadcast _ _ _ prod -> new_p = Seq (prod data) (getNext old_p)
               | _ -> false
             end
end

module MPI_prop

use MPI_Protocol
use MPI_Protocol_Handler

predicate isLineare (p : protocol) =
        match p with
        | Seq (Seq _ _ ) _ -> false
        | _ -> true
        end

predicate isBasic (p : protocol) =
        match p with
        | Seq _ _  -> false
        | _ -> true
        end

predicate isComposed (p : protocol) =
        match p with
        | Seq _ _  -> true
        | _ -> false
        end

lemma test1: forall p1,p2:protocol. isLineare (Seq p1 p2) -> getNext (Seq p1 p2) = p2

lemma test2: forall p1:protocol. isBasic p1 -> getNext p1 = Skip

lemma test3: forall p1,p2:protocol. isLineare (Seq p1 p2) -> getFirst (Seq p1 p2) = p1

lemma test4: forall p1:protocol. isBasic p1 -> getFirst p1 = p1

lemma test5: forall p1:protocol. isBasic p1 -> p1 = simpl (Seq (getFirst p1) (getNext p1))

lemma test6: forall p1:protocol. isComposed p1 /\ isLineare p1 -> p1 = Seq (getFirst p1 ) (getNext p1 )

end
