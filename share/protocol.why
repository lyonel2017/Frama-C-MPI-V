(**************************************************************************)
(*  This file is part of MPI-V plug-in of Frama-C.                        *)
(*                                                                        *)
(*  Copyright (C) 2020 Lionel Blatter                                     *)
(*                                                                        *)
(*  Lionel Blatter <lionel.blatter@kit.edu>                               *)
(*                                                                        *)
(*  you can redistribute it and/or modify it under the terms of the GNU   *)
(*  Lesser General Public License as published by the Free Software       *)
(*  Foundation, version 2.1.                                              *)
(*                                                                        *)
(*  It is distributed in the hope that it will be useful,                 *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *)
(*  GNU Lesser General Public License for more details.                   *)
(*                                                                        *)
(*  See the GNU Lesser General Public License version 2.1                 *)
(*  for more details (enclosed in the file LICENSE).                      *)
(**************************************************************************)

module MPI_Protocol

type mpi_datatype =
| MPI_char
| MPI_int

val constant size : int

type protocol =
  | Message int int int int mpi_datatype
  | Foreach int int (int -> protocol)
  | While int protocol
  | Seq protocol protocol
  | Skip
  | Broadcast int int mpi_datatype
  | Gather int int mpi_datatype
  | Scatter int int mpi_datatype

(* if bool protocol protocol*)


(* | choice (int list) int int int mpi_datatype)
    A nondet recev require a complete choice (all posibilitiase are in the choice)
    A send check if send to the dest (define in the nondet), if yes he must by in the list of source, if
     the send not to the dest he simpl to skip the nondet and check the rest of the protocol
    The choice can be simpl like foreach
 *)



(*  | IntVal (pred int) (cont int)
    require
    to proof that the variable introduised is the same
    for all process (or the same property ?)

    Maybe use a ghost broadcast
*)

end

module MPI_Protocol_Handler

use int.Int
use option.Option
use array.Array
use MPI_Protocol

val constant rank : int

let constant get_mpi_char : mpi_datatype = MPI_char
let constant get_mpi_int : mpi_datatype = MPI_int

function seq (p1: protocol) (p2: protocol): protocol = Seq p1 p2

predicate isMessage (p:protocol) =
       match p with
         | Message _ _ _ _ _ -> true
         | _ -> false
       end

predicate isForeach (p:protocol) =
       match p with
       | Foreach _ _ _ -> true
       | _ -> false
       end

predicate isSkip (p:protocol) =
       match p with
       | Skip -> true
       | _ -> false
       end

predicate isBroadcast (p: protocol) =
	match p with
	| Broadcast _ _ _ -> true
	| _ -> false
	end

predicate isGather (p: protocol) =
	  match p with
	  | Gather _ _ _ -> true
	  | _ -> false
	  end

predicate isScatter (p: protocol) =
	  match p with
	  | Scatter _ _ _ -> true
	  | _ -> false
	  end

predicate isMessageforSend (p:protocol) (dest: int) (count: int) (tag: int) (datatype: mpi_datatype) =
       match p with
         | Message src dst data_size t mt ->
	           src = rank /\ dest = dst /\ data_size = count /\ tag = t /\ datatype = mt
		   /\ 0 <= src /\ src < size /\ 0 <= dst /\ dst < size /\ dst <> src
         | _ -> false
       end

predicate isMessageforRecv (p:protocol) (source: int) (count: int) (tag: int) (datatype: mpi_datatype) =
       match p with
         | Message src dst data_size t mt ->
	           src = source /\ dst = rank /\ data_size <= count /\ tag = t /\ datatype = mt
		   /\ 0 <= src /\ src < size /\ 0 <= dst /\ dst < size /\ dst <> src
         | _ -> false
       end

predicate isforBroadcast (p: protocol) (root: int) (count: int) (datatype: mpi_datatype) =
	match p with
	  | Broadcast r data_size mt -> root = r /\  data_size = count /\ datatype = mt
	    	      /\ 0 <= r /\ r < size
	  | _ -> false
        end

predicate isforGather (p: protocol) (root: int) (count: int) (datatype: mpi_datatype) =
	match p with
	  | Gather r data_size mt -> root = r /\  data_size = count /\ datatype = mt
	    	     /\ 0 <= r /\ r < size
	  | _ -> false
        end

predicate isforScatter (p: protocol) (root: int) (count: int) (datatype: mpi_datatype) =
	match p with
	  | Scatter r data_size mt -> root = r /\  data_size = count /\ datatype = mt
	    	    /\ 0 <= r /\ r < size
	  | _ -> false
        end

function simpl (p: protocol) : protocol =
	 match p with
	 | Seq Skip q -> q
	 | Seq h Skip -> h
         | Message source dest _ _ _ ->
            if rank <> source /\ rank <> dest /\
	       0 <= source /\ source < size /\ 0 <= dest /\ dest < size /\ dest <> source
            then Skip
            else p
	 | Foreach low high body ->
	    if low <= high
  	    then Seq (body low) (Foreach (low + 1) high body)
 	    else Skip
	 | While n body ->
	    if n > 0
	    then Seq body (While (n-1) body)
	    else Skip
         | _ -> p
         end

function split (p: protocol) (c : int): protocol  =
        match p with
       | Foreach low high body ->
         if low <= c <= high
         then Seq (Foreach low (c-1) body) (Foreach c high body)
	 else if low <= high < c
	 then Seq (Foreach low high body) (Foreach c high body)
         else if c < low <= high
	 then Seq (Foreach low c body) (Foreach low high body)
	 else p
       | While n body ->
         if 0 <= c <= n
         then Seq (While c body) (While (n-c) body)
         else if 0 <= n < c
	 then Seq (While n body) (While (n-c) body)
	 else if c < 0 <= n
	 then Seq (While c body) (While n body)
	 else p
       | _ -> p
        end

function assoc (p:protocol) :protocol =
	 match p with
	 | Seq (Seq h q) p -> Seq h (Seq q p)
	 | p -> p
	 end

let rec function getFirst (p: protocol) : protocol variant {p} =
           match p with
	   | Seq h _ -> getFirst h
	   | p -> p
	   end

let rec function aux (p: protocol) : option protocol variant {p} =
          match p with
	   | Seq h q ->
               	   match (aux h) with
         	   | None -> Some q
	           | Some p ->  Some (Seq p q)
		   end
	   | _ -> None
	   end

let function getNext (p: protocol): protocol =
        match aux p with
	| None -> Skip
	| Some p -> p
	end
end

module MPI_prop

use MPI_Protocol
use MPI_Protocol_Handler

predicate isLineare (p : protocol) =
        match p with
	   | Seq (Seq _ _ ) _ -> false
	   | _ -> true
        end

predicate isBasic (p : protocol) =
        match p with
	   | Seq _ _  -> false
	   | _ -> true
        end

predicate isComposed (p : protocol) =
        match p with
	   | Seq _ _  -> true
	   | _ -> false
        end

lemma test1: forall p1,p2:protocol. isLineare (Seq p1 p2) -> getNext (Seq p1 p2) = p2

lemma test2: forall p1:protocol. isBasic p1 -> getNext p1 = Skip

lemma test3: forall p1,p2:protocol. isLineare (Seq p1 p2) -> getFirst (Seq p1 p2) = p1

lemma test4: forall p1:protocol. isBasic p1 -> getFirst p1 = p1

lemma test5: forall p1:protocol. isBasic p1 -> p1 = simpl (Seq (getFirst p1) (getNext p1))

lemma test6: forall p1:protocol. isComposed p1 /\ isLineare p1 -> p1 = Seq (getFirst p1 ) (getNext p1 )

end
