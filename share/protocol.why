module MPI_Protocol

use int.Int
use option.Option

type mpi_type =
| MPI_int
| MPI_char

type protocol =
  | Message int int mpi_type
  | Foreach int int (cont int)
  | While int protocol
  | Seq protocol protocol
  | Skip
  | Dead
(*  | IntVal (pred int) (cont int)*)
(*require to proof that the variable introduised is the same for all porcess: relational property*)
with pred 'a = 'a -> bool
with cont 'a = 'a -> protocol


val constant rank : int
val constant size : int

type mpi_protocol = {mutable p:protocol}

function simpl (p: protocol) : protocol =
	 match p with
	 | Seq Skip q -> q
	 | Seq h Skip -> h
	 | Seq h q -> Seq (simpl h) q
         | Message source dest _ ->
            if rank <> source /\ rank <> dest
            then Skip
            else p
	 | Foreach low high body ->
	    if low <= high
  	    then Seq (body low) (Foreach (low + 1) high body)
 	    else Skip
	 | While n body ->
	    if n < 0
	    then Skip
	    else Seq body (While (n-1) body)
         | _ -> p
         end

predicate isSkip (p: protocol) =
     match p with
     | Skip -> true
     | _ -> false
     end

predicate foreach_is_Skip (body: cont int) (low high : int) =
   forall i : int. low <= i <= high -> isSkip (simpl (body i))

function split (p: protocol) (c : int): protocol  =
        match p with
	| Foreach low high body ->
	  if low < c < high
	  then Seq (Foreach low c body) (Foreach (c+1) high body)
	  else p
	| While n body ->
	  if c < n
	  then Seq (While c body) (While (n-c) body)
	  else p
	| _ -> p
        end

function matches (t d : mpi_type) : bool =
     match t,d with
     | MPI_int, MPI_int -> true
     | _ , _ -> false
     end

predicate isMessageforSend (p:protocol) (dest: int) (t: mpi_type) =
       match p with
         | Message src dst d -> src = rank /\ dest = dst /\ matches t d
         | _ -> false
       end

predicate isMessageforRecv (p:protocol) (source: int) (t: mpi_type) =
       match p with
       | Message src dst d -> src = source /\ dst = rank /\ matches t d
       | _ -> false
       end

let rec function getFirst (p: protocol) : protocol variant {p} =
           match p with
	   | Seq (Seq h q) _ -> getFirst (Seq h q)
	   | Seq h _ -> h
	   | p -> p
	   end

let rec function getNext (p: protocol) : protocol variant {p} =
           match p with
	   | Seq (Seq h q) qq -> Seq (getNext (Seq h q)) qq
	   | Seq _ q -> q
	   | _ -> Dead
	   end
 end


module MPI_Function

use MPI_Protocol
use int.Int

val init (s:mpi_protocol) (p:protocol) :unit
    writes {s.p}
    ensures{s.p=p}
    ensures{0 <= rank < size}

val send (dest:int) (t:mpi_type) (s:mpi_protocol): unit
    writes { s.p }
    requires { 0 <= dest /\ dest < size }
    requires { isMessageforSend (getFirst s.p) dest t}
    ensures { s.p = getNext (old s).p }

val recv (source:int) (t:mpi_type) (s:mpi_protocol): unit
    writes { s.p }
    requires { 0 <= source /\ source < size }
    requires { isMessageforRecv (getFirst s.p) source t }
    ensures { s.p = getNext (old s).p }

val simpl (s:mpi_protocol): unit
    writes {s.p}
    ensures{s.p= simpl (old s).p}

val simpl_foreach (s:mpi_protocol) : unit
    writes {s.p}
    (* requires { isForeach (getFirst s.p) && foreach_is_Skip} *)
    (* ensures { s.p = getNext (old s).p } *)

    (*requires a foreach and if all are skip take next*)


val function finalize (s: mpi_protocol) : unit
    requires {isSkip (s.p)}

end


module MPI_example

use MPI_Protocol
use MPI_Function
use int.Int

let p : mpi_protocol = {p = Dead}

let test1 () : unit
requires {size >= 2}
=
    init p (Foreach 0 0 (fun i -> Message i (i+1) MPI_int));
    if rank = 0 then (
       simpl p;
       send 1 MPI_int p;
       simpl p;
       assert {isSkip (p.p)}
    )
    else if (rank = 1) then (
         simpl p;
    	 recv 0 MPI_int p;
	 simpl p;
       assert {isSkip (p.p)}
    )
    else (
    simpl p;
    simpl p;
    simpl p;
    simpl p;
    assert {isSkip (p.p)}
    );
   finalize p
end