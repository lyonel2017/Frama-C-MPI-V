module MPI_Protocol

use int.Int
use option.Option
use array.Array

type mpi_datatype =
| MPI_char
| MPI_int

let constant get_mpi_char : mpi_datatype = MPI_char
let constant get_mpi_int : mpi_datatype = MPI_int

val constant rank : int
val constant size : int

type protocol =
  | Message int int int int mpi_datatype
  | Foreach int int (int -> protocol)
  | While int protocol
  | Seq protocol protocol
  | Skip
  | Broadcast int int mpi_datatype


  | Dead (*two different dead: entry en exit*)
(* | Entry *)
(* | Exit *)



(* gather *)
(* scater *)
(* | Nondet protocol  protocol *)
(*  | IntVal (pred int) (cont int)
    require
    to proof that the variable introduised is the same
    for all process (or the same property ?)

    Maybe use a ghost broadcast
*)

let constant get_protocol_dead : protocol = Dead
function seq (p1: protocol) (p2: protocol): protocol = Seq p1 p2

predicate isDead(p: protocol) =
         match p with
           | Dead -> true
           | _ -> false
         end

predicate isMessage (p:protocol) =
       match p with
         | Message _ _ _ _ _ -> true
         | _ -> false
       end

predicate isForeach (p:protocol) =
       match p with
       | Foreach _ _ _ -> true
       | _ -> false
       end

predicate isSkip (p:protocol) =
       match p with
       | Skip -> true
       | _ -> false
end

predicate isMessageforSend (p:protocol) (dest: int) (count: int) (tag: int) (datatype: mpi_datatype) =
       match p with
         | Message src dst size t mt ->
	           src = rank /\ dest = dst /\ size = count /\ tag = t /\ datatype = mt
         | _ -> false
       end

predicate isMessageforRecv (p:protocol) (source: int) (count: int) (tag: int) (datatype: mpi_datatype) =
       match p with
         | Message src dst size t mt ->
	           src = source /\ dst = rank /\ size <= count /\ tag = t /\ datatype = mt
         | _ -> false
       end

predicate isBroadcast (p: protocol) (root: int) (count: int) (datatype: mpi_datatype) =
	match p with
	  | Broadcast r size mt -> root = r /\  size = count /\ datatype = mt
	  | _ -> false
        end

function simpl (p: protocol) : protocol =
	 match p with
	 | Seq Skip q -> q
	 | Seq h Skip -> h
         | Message source dest _ _ _ ->
            if rank <> source /\ rank <> dest
            then Skip
            else p
	 | Foreach low high body ->
	    if low <= high
  	    then Seq (body low) (Foreach (low + 1) high body)
 	    else Skip
	 | While n body ->
	    if n > 0
	    then Seq body (While (n-1) body)
	    else Skip
         | _ -> p
         end

function split (p: protocol) (c : int): protocol  =
        match p with
       | Foreach low high body ->
         if low <= c <= high
         then Seq (Foreach low (c-1) body) (Foreach c high body)
	 else if low <= high < c
	 then Seq (Foreach low high body) (Foreach c high body)
         else if c < low <= high
	 then Seq (Foreach low c body) (Foreach low high body)
	 else p
       | While n body ->
         if 0 <= c <= n
         then Seq (While c body) (While (n-c) body)
         else if 0 <= n < c
	 then Seq (While n body) (While (n-c) body)
	 else if c < 0 <= n
	 then Seq (While c body) (While n body)
	 else p
       | _ -> p
        end

function assoc (p:protocol) :protocol =
	 match p with
	 | Seq (Seq h q) p -> Seq h (Seq q p)
	 | p -> p
	 end

let rec function getFirst (p: protocol) : protocol variant {p} =
           match p with
	   | Seq h _ -> getFirst h
	   | p -> p
	   end

let rec function aux (p: protocol) : option protocol variant {p} =
          match p with
	   | Seq h q ->
               	   match (aux h) with
         	   | None -> Some q
	           | Some p ->  Some (Seq p q)
		   end
	   | _ -> None
	   end

let function getNext (p: protocol): protocol =
        match aux p with
	| None -> Skip
	| Some p -> p
	end
end

module MPI_prop

use MPI_Protocol

predicate isLineare (p : protocol) =
        match p with
	   | Seq (Seq _ _ ) _ -> false
	   | _ -> true
        end

predicate isBasic (p : protocol) =
        match p with
	   | Seq _ _  -> false
	   | _ -> true
        end

predicate isComposed (p : protocol) =
        match p with
	   | Seq _ _  -> true
	   | _ -> false
        end

lemma test1: forall p1,p2:protocol. isLineare (Seq p1 p2) -> getNext (Seq p1 p2) = p2

lemma test2: forall p1:protocol. isBasic p1 -> getNext p1 = Skip

lemma test3: forall p1,p2:protocol. isLineare (Seq p1 p2) -> getFirst (Seq p1 p2) = p1

lemma test4: forall p1:protocol. isBasic p1 -> getFirst p1 = p1

lemma test5: forall p1:protocol. isBasic p1 -> p1 = simpl (Seq (getFirst p1) (getNext p1))

lemma test6: forall p1:protocol. isComposed p1 /\ isLineare p1 -> p1 = Seq (getFirst p1 ) (getNext p1 )

end
