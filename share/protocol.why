module MPI_Protocol

use int.Int
use option.Option

type mpi_type =
| MPI_int
| MPI_char

type protocol =
  | Message int int mpi_type
  | Foreach int int (cont int)
  | While int protocol    
  | Seq protocol protocol (*supprimer le sequent et remetre l'induction sur les autre contructeur *)
  | Skip
(*  | IntVal (pred int) (cont int)*) (*require to proof that the variable introduised is the same for all porcess: relational property*)
with pred 'a = 'a -> bool
with cont 'a = 'a -> protocol


val constant rank : int
val constant size : int

type mpi_protocol = {mutable p:protocol}

function simpl (p: protocol) : protocol =
	 match p with
	 | Seq Skip q -> q
	 | Seq h Skip -> h
	 | Seq h q -> Seq (simpl h) q
         | Message source dest _ ->
            if rank <> source /\ rank <> dest
            then Skip
            else p
	 | Foreach low high body ->
	    if low <= high
  	    then Seq (body low) (Foreach (low + 1) high body)
 	    else Skip
	 | While n body ->
	    if n < 0
	    then Skip
	    else Seq body (While (n-1) body)
         | _ -> p
         end

predicate isSkip (p: protocol) =
     match p with
     | Skip -> true
     | _ -> false
     end

function split (p: protocol) (c : int): protocol  =
        match p with
	| Foreach low high body ->
	  if low <= c <= high
	  then Seq (Foreach low (c-1) body) (Foreach c high body)
	  else p
	| While n body ->
	  if c < n
	  then Seq (While c body) (While (n-c) body)
	  else p
	| Seq h q -> Seq (split h c) q
	| _ -> p
        end

function matches (t d : mpi_type) : bool =
     match t,d with
     | MPI_int, MPI_int -> true
     | _ , _ -> false
     end

predicate isMessage (p:protocol) =
       match p with
         | Message _ _ _ -> true
         | _ -> false
       end

predicate isMessageforSend (p:protocol) (dest: int) (t: mpi_type) =
       match p with
         | Message src dst d -> src = rank /\ dest = dst /\ matches t d
         | _ -> false
       end

predicate isMessageforRecv (p:protocol) (source: int) (t: mpi_type) =
       match p with
       | Message src dst d -> src = source /\ dst = rank /\ matches t d
       | _ -> false
       end

predicate isForeach (p:protocol) =
       match p with
       | Foreach _ _ _ -> true
       | _ -> false
       end

predicate isForeachSkip (p:protocol) =
       match p with
       | Foreach low high body ->
              forall i : int. low <= i <= high -> isSkip (simpl (body i))
       | Skip -> true
       | _ -> false
       end

let rec function getFirst (p: protocol) : protocol variant {p} =
           match p with
	   | Seq (Seq h q) _ -> getFirst (Seq h q)
	   | Seq h _ -> h
	   | p -> p
	   end

let rec function getNext (p: protocol) : protocol variant {p} =
           match p with
	   | Seq (Seq h q) qq -> Seq (getNext (Seq h q)) qq
	   | Seq _ q -> q
	   | _ -> Skip
	   end
 end


module MPI_Function

use MPI_Protocol
use int.Int

val init (s:mpi_protocol) (p:protocol) :unit
    writes {s.p}
    ensures{s.p=p}
    ensures{0 <= rank < size}

val send (dest:int) (t:mpi_type) (s:mpi_protocol): unit
    writes { s.p }
    requires { 0 <= dest /\ dest < size }
    requires { isMessageforSend (getFirst s.p) dest t}
    ensures { s.p = getNext (old s).p }

val recv (source:int) (t:mpi_type) (s:mpi_protocol): unit
    writes { s.p }
    requires { 0 <= source /\ source < size }
    requires { isMessageforRecv (getFirst s.p) source t }
    ensures { s.p = getNext (old s).p }

val simpl (s:mpi_protocol): unit
    writes {s.p}
    ensures{s.p= simpl (old s).p}

val split (s:mpi_protocol) (c: int): unit
    writes {s.p}
    ensures{s.p= split (old s).p c}

val simpl_foreach (s:mpi_protocol) : unit
    writes {s.p}
    requires { isForeachSkip (getFirst s.p)}
    ensures { s.p = getNext (old s).p }

val function finalize (s: mpi_protocol) : unit
    requires {isSkip (s.p)}

end


module MPI_example

use MPI_Protocol
use MPI_Function
use int.Int

let p : mpi_protocol = {p = Skip}

let test1 () : unit
requires {size >= 2}
=
    init p (Foreach 0 0 (fun i -> Message i (i+1) MPI_int));
    if rank = 0 then (
       simpl p;
       send 1 MPI_int p;
       simpl p;
    )
    else if (rank = 1) then (
         simpl p;
    	 recv 0 MPI_int p;
	 simpl p;
    )
    else (
      simpl p;
      simpl p;
      simpl p;
      simpl p;
    );
   finalize p

let test2 () : unit
requires {size >= 20}
=
    init p (Foreach 0 9 (fun i -> Message i (i+10) MPI_int));
    if rank < 5 then (
       split p rank;
       assert {p.p = Seq (Foreach 0 (rank-1) (fun i -> Message i (i+10) MPI_int)) (Foreach rank 9 (fun i -> Message i (i+10) MPI_int))};
       simpl_foreach p;
       simpl p;
       send (rank+10) MPI_int p;
       simpl_foreach p
    )
    else if (rank < 10 ) then (
       split p rank;
       simpl_foreach p;
       simpl p;
       send (rank+10) MPI_int p;
       simpl_foreach p
    )
    else if (rank < 20) then (
       split p (rank-10);
       assert {p.p = Seq (Foreach 0 (rank-10-1) (fun i -> Message i (i+10) MPI_int)) (Foreach (rank-10) 9 (fun i -> Message i (i+10) MPI_int))};
       simpl_foreach p;
       simpl p;
       recv (rank - 10) MPI_int p;
       simpl_foreach p
    )
    else (
       simpl_foreach p;
    );
   finalize p


(*While loop : unfold like a liste to list: look at example with lists: at the end empty list*)

end