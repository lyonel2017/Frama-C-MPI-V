(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require option.Option.

(* Why3 assumption *)
Inductive mpi_type :=
  | MPI_int : mpi_type
  | MPI_char : mpi_type.
Axiom mpi_type_WhyType : WhyType mpi_type.
Existing Instance mpi_type_WhyType.

(* Why3 assumption *)
Inductive protocol :=
  | Message : Numbers.BinNums.Z -> Numbers.BinNums.Z -> mpi_type -> protocol
  | Foreach : Numbers.BinNums.Z -> Numbers.BinNums.Z ->
      (Numbers.BinNums.Z -> protocol) -> protocol
  | While : Numbers.BinNums.Z -> protocol -> protocol
  | Seq : protocol -> protocol -> protocol
  | Skip : protocol.
Axiom protocol_WhyType : WhyType protocol.
Existing Instance protocol_WhyType.

(* Why3 assumption *)
Definition pred (a:Type) := a -> Init.Datatypes.bool.

(* Why3 assumption *)
Definition cont (a:Type) := a -> protocol.

Parameter rank: Numbers.BinNums.Z.

Parameter size: Numbers.BinNums.Z.

(* Why3 assumption *)
Inductive mpi_protocol :=
  | mpi_protocol'mk : protocol -> mpi_protocol.
Axiom mpi_protocol_WhyType : WhyType mpi_protocol.
Existing Instance mpi_protocol_WhyType.

(* Why3 assumption *)
Definition p (v:mpi_protocol) : protocol :=
  match v with
  | mpi_protocol'mk x => x
  end.

Parameter simpl: protocol -> protocol.

Axiom simpl'def :
  forall (p1:protocol),
  match p1 with
  | Seq Skip q => ((simpl p1) = q)
  | Seq h Skip => ((simpl p1) = h)
  | Seq h q => ((simpl p1) = (Seq (simpl h) q))
  | Message source dest _ =>
      (~ (rank = source) /\ ~ (rank = dest) -> ((simpl p1) = Skip)) /\
      (~ (~ (rank = source) /\ ~ (rank = dest)) -> ((simpl p1) = p1))
  | Foreach low high body =>
      ((low <= high)%Z ->
       ((simpl p1) = (Seq (body low) (Foreach (low + 1%Z)%Z high body)))) /\
      (~ (low <= high)%Z -> ((simpl p1) = Skip))
  | While n body =>
      ((n < 0%Z)%Z -> ((simpl p1) = Skip)) /\
      (~ (n < 0%Z)%Z -> ((simpl p1) = (Seq body (While (n - 1%Z)%Z body))))
  | _ => ((simpl p1) = p1)
  end.

(* Why3 assumption *)
Definition isSkip (p1:protocol) : Prop :=
  match p1 with
  | Skip => True
  | _ => False
  end.

Parameter split: protocol -> Numbers.BinNums.Z -> protocol.

Axiom split'def :
  forall (p1:protocol) (c:Numbers.BinNums.Z),
  match p1 with
  | Foreach low high body =>
      ((low <= c)%Z /\ (c <= high)%Z ->
       ((split p1 c) =
        (Seq (Foreach low (c - 1%Z)%Z body) (Foreach c high body)))) /\
      (~ ((low <= c)%Z /\ (c <= high)%Z) -> ((split p1 c) = p1))
  | While n body =>
      ((c < n)%Z ->
       ((split p1 c) = (Seq (While c body) (While (n - c)%Z body)))) /\
      (~ (c < n)%Z -> ((split p1 c) = p1))
  | Seq h q => ((split p1 c) = (Seq (split h c) q))
  | _ => ((split p1 c) = p1)
  end.

(* Why3 assumption *)
Definition matches (t:mpi_type) (d:mpi_type) : Init.Datatypes.bool :=
  match (t, d) with
  | (MPI_int, MPI_int) => Init.Datatypes.true
  | (_, _) => Init.Datatypes.false
  end.

(* Why3 assumption *)
Definition isMessage (p1:protocol) : Prop :=
  match p1 with
  | Message _ _ _ => True
  | _ => False
  end.

(* Why3 assumption *)
Definition isMessageforSend (p1:protocol) (dest:Numbers.BinNums.Z)
    (t:mpi_type) : Prop :=
  match p1 with
  | Message src dst d =>
      (src = rank) /\ (dest = dst) /\ ((matches t d) = Init.Datatypes.true)
  | _ => False
  end.

(* Why3 assumption *)
Definition isMessageforRecv (p1:protocol) (source:Numbers.BinNums.Z)
    (t:mpi_type) : Prop :=
  match p1 with
  | Message src dst d =>
      (src = source) /\ (dst = rank) /\ ((matches t d) = Init.Datatypes.true)
  | _ => False
  end.

(* Why3 assumption *)
Definition isForeach (p1:protocol) : Prop :=
  match p1 with
  | Foreach _ _ _ => True
  | _ => False
  end.

(* Why3 assumption *)
Definition isForeachSkip (p1:protocol) : Prop :=
  match p1 with
  | Foreach low high body =>
      forall (i:Numbers.BinNums.Z), (low <= i)%Z /\ (i <= high)%Z ->
      isSkip (simpl (body i))
  | Skip => True
  | _ => False
  end.

Parameter getFirst: protocol -> protocol.

Axiom getFirst'def :
  forall (p1:protocol),
  match p1 with
  | Seq (Seq h q) _ => ((getFirst p1) = (getFirst (Seq h q)))
  | Seq h _ => ((getFirst p1) = h)
  | p2 => ((getFirst p1) = p2)
  end.

Parameter getNext: protocol -> protocol.

Axiom getNext'def :
  forall (p1:protocol),
  match p1 with
  | Seq (Seq h q) qq => ((getNext p1) = (Seq (getNext (Seq h q)) qq))
  | Seq _ q => ((getNext p1) = q)
  | _ => ((getNext p1) = Skip)
  end.

Parameter finalize: mpi_protocol -> Init.Datatypes.unit.

Axiom Requires : (20%Z <= size)%Z.

Parameter p1: protocol.

Axiom Ensures :
  (p1 =
   (Foreach 0%Z 9%Z
    (fun (i:Numbers.BinNums.Z) => Message i (i + 10%Z)%Z MPI_int))).

Axiom H : (0%Z <= rank)%Z.

Axiom H1 : (rank < size)%Z.

Axiom H2 : ~ (rank < 5%Z)%Z.

Axiom H3 : ~ (rank < 10%Z)%Z.

Axiom H4 : (rank < 20%Z)%Z.

Parameter p2: protocol.

Axiom Ensures1 : (p2 = (split p1 (rank - 10%Z)%Z)).

(* Why3 goal *)
Theorem test2'vc :
  (p2 =
   (Seq
    (Foreach 0%Z ((rank - 10%Z)%Z - 1%Z)%Z
     (fun (i:Numbers.BinNums.Z) => Message i (i + 10%Z)%Z MPI_int))
    (Foreach (rank - 10%Z)%Z 9%Z
     (fun (i:Numbers.BinNums.Z) => Message i (i + 10%Z)%Z MPI_int)))).
Proof.
rewrite Ensures1.
rewrite Ensures.
destruct (split'def (Foreach 0 9 (fun i : int => Message i (i + 10) MPI_int)) (rank-10)).
rewrite H0.
+ reflexivity.
+ specialize H4. specialize H. specialize H3. omega.
Qed.

